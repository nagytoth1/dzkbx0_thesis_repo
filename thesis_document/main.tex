\documentclass[tocnopagenum]{thesis-ekf}
%a4paper, 12pt, 1.5-es sortávolság, margók
\PassOptionsToPackage{defaults=hu-min}{magyar.ldf}
\usepackage[magyar]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{mathtools,amssymb,amsthm,pdfpages, subcaption, comment, enumitem, booktabs, graphicx, fancyvrb, algorithm, algpseudocode}
\footnotestyle{rule=fourth}
\captionsetup[subfigure]{labelformat=empty} % subcaptionre ne tegyen számozást
\graphicspath{{./images/}} % képeket innen importálom be
\DeclareGraphicsExtensions{.png,.PNG,.jpg,.JPG,.pdf,.PDF} %ezeken a kiterjesztéseken keresse a képeket
\renewcommand{\thesection}{\thechapter.\number\numexpr\value{section}-1\relax}
\renewcommand{\thesubsection}{\thesection.\number\numexpr\value{subsection}-1\relax}
\setcounter{secnumdepth}{2}
\setcounter{chapter}{1}

\begin{document}
	\institute{Matematikai és Informatikai Intézet}
	\title{Interfész megoldások imperatív és OOP nyelvek közötti kapcsolattartásra}
	\author{Nagy-Tóth Bence\\Szak: Programtervező informatikus\\Specializáció: Szoftverfejlesztő informatikus}
	\supervisor{Dr. Király Roland\\egyetemi docens}
	\city{Eger}
	\date{\the\year{}}
	\VerbatimFootnotes
	\maketitle
	\tableofcontents
	\begin{abstract}
		Szakdolgozatomban kifejtem az \textit{interlingvális}\footnote{Az interlingua kifejezés a latin \textit{inter} (között) és \textit{lingua} (nyelv) szavak összetételéből adódik. Jelentése ,,nyelvek között''.} kommunikáció lehetséges megvalósítási módjait, amelynek legfontosabb mérföldköve a szöveges adatok valamilyen szabvány szerinti közlése, tehát a szerializáció lesz, amelynek segítségével képessé válhatunk bármilyen típusú adatot -- legyen az szám, logikai változó, egy teljes, több attribútumból felépülő objektum -- ilyen formában a másik program részére közölni. Miután ez a szabványos formátum elkészült, az a feladatunk, hogy a másik oldalt is felkészítsük a közlések fogadására és feldolgozására. Ennek gyakorlati haszna bemutatásra kerül egy, a szakdolgozatunkhoz készített szoftver keretein belül, amelynek célja, hogy különböző típusú eszközöket vezéreljünk a C\# nyelvi adottságaival SLFormHelper, valamint Delphi-Assembly-kódból készült SLDLL állományok munkájának összehangolásával. Ez a két DLL\footnote{A DLL-ek -- ez a \textit{Dynamically Linked Library} kifejezés rövidítése -- csak Windows operációs rendszerben hasznosítható fájlok, amelyek segédkönyvtárként használhatóak, lefordított, gépi kódú állapotban vannak, ezeket a valódi futtatható programok használhatják. Mivel ezek már lefordított ál}, mint később látni fogjuk, nem lesz elegendő, szükség volt egy harmadik, úgynevezett relayDLL-re, amely áthidalja a két nyelv sajátosságait, és ténylegesen olyan elemeket használ, amelyet mindkét nyelv hasznosítani tud a maga számára. Ezt én készítettem abból a célból, hogy az adatok cseréje tulajdonképpen ezen a ,,hídon'' keresztül, kezelhetőbb módon jöhessen létre a Delphi és a C\# programozási nyelvek között. 
		
		Kutatásom utolsó fázisában tettem egy kitérőt a C programozási nyelv irányában is, a C-forráskódból elkészült harmadik, converter32 alkalmasnak bizonyult a Delphiben készített relayDLL állománnyal való együttműködésre, így a Delphi és a C programozási nyelvek között is sikerült egy függvényhívás erejéig kapcsolatot teremtenem.
		
		A szoftverek felújításának problémája nem ritkán előfordulhat más kontextusban is, ugyanis vannak vállalkozások, amelyek nem merik leváltani jól bevált, régi (legacy) rendszereiket, mivel egyszerűen túl sok időbe és pénzbe kerülne azokat új köntösbe bújtatni, és felmerülhet, hogy esetleg nem sikerül minden funkciót teljesen, maradéktalanul átültetni egy fejlettebb programozási nyelvre. Nem beszélve arról, hogy az új rendszerre való áttérés során fennállhat az adatvesztés kockázata is. Ezek kiküszöbölésére érdemes lenne -- mint a számítógépes hálózatok esetében is --  szabványos formátumokat használnunk az adatok tárolására, szállítására és helyreállítására. Ha mégis erre adná a fejét egy szoftverfejlesztő csapat, akkor annak általában az a lefutása, hogy a nulláról elkezdik a választott új nyelvvel leírni a régi rendszert. A megoldás kulcsa jelen álláspontom szerint a szerializáció lehetne, amely lehetővé tenné, hogy szabványos formátumokon dolgozó régi egységeket az új környezetből is meghívhassuk, jelentősen csökkentve az új rendszer implementációjára fordított időt.
	\end{abstract}
	\section{Bevezetés}
	A kognitív képességek hozzájárulnak elménkben lezajló folyamatok jelentős részéhez, ezért azok fejlesztésére érdemes odafigyelnünk életünk során. Ezen megállapításom különösen beigazolódni egy COVID-világjárvány utáni időszak tendenciáinak tükrében.
	A járványra reagáló korlátozó intézkedések következtében nőtt a különböző mentális betegségek kialakulásának kockázata. \cite{brain1} 
	A \textit{demencia} gyűjtőfogalomként alkalmas ezen betegségek együttes megnevezésére.\footnote{A demencia említésekor nem egyetlen betegségre, hanem több hasonló jellegű problémát  csoportosító fogalomra, egy tünetegyüttesre gondolunk. Száznál is több típusát ismerik a demenciának, amelyek közül az Alzheimer-kór a leggyakoribb. \cite{demencia_egeszsegvonal}}
	
	A különböző digitális eszközök használata számtalan alkalommal hosszas órákon keresztül képes lekötni a figyelmünket, ezért bizonyos külső ingerekre egyre lassabban, kisebb amplitúdóval, azaz nagyobb közömbösséggel tudunk reagálni. 
	
	A demencia, azaz a kognitív képességek leépülésének tünetei közé tartoznak a különböző beszédzavarok, az ítélőképesség, a memorizálás és az elvonatkoztatás képességeinek romlása.
	
	Az értelmi hanyatlást különféle egészségkárosító szokások -- például az alkoholfogyasztás -- szervi károsodás, akár ezek együttese is okozhatja. Sajnos, az ember életkorának előrehaladtával szintén egyre nő a kockázata a demencia kialakulásának.
	
	Szakemberek véleménye szerint a megfelelő étrendek megalkotásával, a társas interakciók intenzitásának és tartalmi színvonalának növelésével, az emberek képzésével mind iskolai, mind munkahelyi szinten megelőzhetjük agyi teljesítőképességünk romlását. 
	Kifejezetten  preventív jelleggel hatnak a különféle társasjátékok, valamint a rejtvényfejtés.\\Egy szó, mint száz: bármi, amivel munkára bírjuk agyunkat, alkalmas arra, hogy gátat vessen annak romlásának.
	Végül és abszolút nem utolsó sorban említhetjük a mozgás fontosságát, munkánkban a demencia megfékezésének ezen útját választottuk.
	
	Szakdolgozatom ezen pontján azért érdemes erről a betegségről szót ejtenem, mivel alapvetően számomra már önmagában motivációul szolgál a tudat, hogy egy ilyen nagy volumenű elmélet megvalósításában vehetek részt, amely a demencia megelőzését, a mentális állapot folyamatos rongálódásának megfékezését célozza. 
	\cite{dementia1}
	\cite{dementia2}
	\cite{dementia3}
	
	Az általunk készített szoftver támogatást nyújthat csoportfoglalkozásokon, tulajdonképpen egy tornaórát le tudunk vezényelni az eszközöknek köszönhetően. Természetesen az eszközök által kibocsájtott különböző fény- és hangjelzések önmagukban nem hordoznak semmiféle jelentést, a jelzések konkrét  a tornaórákat vezénylő szakemberek dolga közölni a csoport számára.
	
	Bevezetésem ezen részén szeretném egy kicsit górcső alá venni témám címét. Ehhez először is meg kell ismerkednünk a címben szereplő két programozási paradigmával.
	
	Az imperatív\footnote{Az \textit{imperare} latin szóból eredő szó, jelentése: parancsol} programozási paradigma arról szól, hogy a számítógépet egyértelműen, előre meghatározott utasításkészlettel vezéreljük, le kell írnunk a problémát megoldó lépéssorozatot, algoritmust, így az elkészült forráskódot ilyen lépéssorozatok együttese teszi ki. Az algoritmusok implementálásához változókat és vezérlési szerkezeteket (elágazás, ciklus és szekvencia) használunk. Az efféle megközelítést támogató nyelveket nevezzük imperatívnak. Ilyenek például a Java, a C, C++, C\# és a Delphi.
	
	Az objektumorientált programozási (röviden: OOP) paradigma igyekszik a világot lemodellezni olyan formában, hogy a modellt objektumok használatával írja le. 
	Az objektumelvű programozás alaptételei:
	\begin{itemize}
		\item \textbf{egységbe zárás}: Az OOP egyik alaptézise, hogy az adatszerkezet és a rajtuk végzett műveletek egy egységben, az osztályban összpontosulnak. Ezt másképp úgy is ki lehet fejezni, hogy egy objektumhoz szorosan, logikailag hozzátartozik annak belső állapota -- ezt mezőnek hívjuk -- és viselkedése (a metódusok). Az osztály tagjait elláthatjuk láthatósági szintekkel, ezek közül a private szint kizárólag osztályon belüli láthatóságot biztosít, ekkor például egy \verb*|LEDLight|-típusú objektumhoz tartozó szín mező értékéhez kívülről, közvetlenül nem lehet hozzáférni, csakis az osztályon belül használható. Ha viszont minden csak private szinttel lenne ellátva, nem tudnánk az objektumokat érdemben használni, mivel az osztályok mezőit nem tudnánk sem írni sem olvasni. Ennek kiküszöbölésére publikus szintű metódusokkal engedélyt adhatunk a objektum adattagjaihoz való hozzáférésre, ezzel ellenőrzéseket, validációkat bevezetve eldönthetjük, hogy a hozzáférést valóban megadjuk-e.

		\item \textbf{öröklődés}: Az objektumok gyakran bizonyos tulajdonságaikban hasonlítanak egymásra. Például van egy lámpa eszköz vezérlésére szolgáló \verb*|LEDLight|-osztály, amelynek egyetlen példányát leírja annak színe és azonosítója, viszont ezután szeretnénk egy másik osztályt is, amely szintén ezekkel az attribútumokkal rendelkezne, egy ráadással: irányt is szeretnénk hozzárendelni az eszköz beállításaihoz. Látjuk, hogy 3 tulajdonságból 2 megegyezne, ezért az öröklődést választjuk: a megegyező mezőket szervezhetjük úgy, hogy ezek egy úgynevezett szülőosztály részét képezzék (jelen esetben ez a meglévő \verb*|LEDLight|-osztály), majd ebből származtatunk ennek egy gyermekosztályát, ami \verb*|LEDArrow|  névre hallgat. Így a két osztály között kialakult egy öröklődési kapcsolat, a \verb*|LEDArrow| kiterjeszti\footnote{A Java-nyelv szó szerint az ,,extends'' kulcsszóval hangsúlyozza, hogy a gyermekosztály kibővíti szülője funkcionalitását.} szülője, a \verb*|LEDLight| tulajdonságait. Általánosságban elmondható, hogy ennek segítségével a gyermekosztály mindig csak annyit tesz hozzá, amennyi tőle szükséges, miközben megörökli a szülőosztályának logikáját.
		A gyermekosztály újra felhasználja a szülőosztály összes mezőjét és metódusát (közös rész), és megvalósíthatja a sajátját (egyedi rész).
		\item \textbf{absztrakció}: Ami a felhasználó kód számára nem lényeges információ, azt elrejtjük. Az egységbe zárás következtében az osztályban védettségi szinteket tudunk beállítani annak mezőire és metódusaira. a protected az öröklődési láncban gyermekek és szülőosztályok számára engedélyezi a láthatóságot, míg a public láthatósági szinttel biztosítjuk, hogy az adott osztály tagja kívülről is elérhető, hivatkozható. Például szolgálhat a saját autónk: nem feltétlenül kell értenünk, hogy a háttérben pontosan mi zajlik le, az autó mely alkotóelemei működnek összehangoltan, amikor azt működtetjük. Ezek a részletek az autóvezetők elöl elrejthetőek, mivel ezekről nem kell tudnunk ahhoz, hogy vezetni tudjuk járműveinket. A későbbiekben említeni fogom a szerver-kliens architektúrán alapuló alkalmazásokat, amelyben általában metódusok fejlécét, meghívási módját ismerheti a kliens, viszont azt, hogy pontosan milyen módon végzi a szerver a számításokat, az a kliens számára nem lényeges, így el van rejtve, azok eredménye számít igazából.
		
		\item \textbf{polimorfizmus}: A polimorfizmus görög eredetű szó, többalakúságot jelent. Van egy metódusunk, amelyet a szülő osztályra implementáltunk - de szeretnénk használni a gyermekosztályokra is. Az általunk készített programból kiindulva ilyen a \verb*|LEDLight| \verb*|GetDeviceSettings|-függvénye. Azt szeretnénk elérni, hogy a \verb*|LEDLight| beállításai mellett jelenjen meg a \verb*|LEDArrow| objektumokban eltárolt irány is valamilyen formában, hogy JSON segítségével ezt is át tudjuk adni a vezérlőfüggvénynek. Ezt polimorfizmus használatával oldjuk meg, ez lehetőséget teremt arra, hogy egy gyermekosztályt pontosan úgy használjunk, mint a szülőjét, így nem lesz zavar a típusok keveredésével.\cite{oop_concepts}
	\end{itemize}
	 Az osztály a belőle készíthető objektumok ,,tervrajzának'' nevezhető. Ennek megfelelően egy osztályba tartoznak a változók és a rajtuk végrehajtható metódusok. Változóinkat és metódusainkat védettségi szintekkel láthatjuk el, hogy a hozzáférést bizonyos erőforrásokhoz korlátozzuk, ellenőrzött módon végezzük. Az osztályok között kapcsolatokat, relációkat teremthetünk: öröklődést vagy birtoklást. Azon nyelvet, amelyek ezt a paradigmát támogatják, objektumorientáltnak minősítjük.
	A fentebb említett nyelvek ezt a paradigmát is támogatják a C nyelv kivételével.
	\section{Kommunikáció adatszerkezeteken keresztül}
	A \emph{Marshalling} egy olyan folyamat, amely összetett típusok átalakítására szolgál, hogy egy nyelv adatszerkezetét a másikkal megértessük. Magyar fordításával nem találkoztam ennek a kifejezésnek, de leginkább talán az 'átalakítás' szóval tudjuk leírni, ami adatszerkezetek esetében annyit tesz, hogy más nyelv által is értelmezhetővé tesszük, kevésbé hagyatkozunk az adott nyelv különlegességeire.\cite{sof_marshalling}
	\par
	A kód további portolhatósága, újrahasznosíthatósága végett megéri szabványos formátumokon keresztül kommunikálni, mint azt tesszük API-k\footnote{Az Application Programming Interface utasítások, szabványok és metódusok halmaza, amely leírja a kommunikációt más, külső szoftverek részére. Az API-k lehetőséget biztosítanak két vagy több szoftver közötti adatok cseréjére, valamint adatokon végzett műveletek végrehajtására úgy, hogy annak mikéntjéről az API írója gondoskodik. Másként fogalmazva: az API a szerver azon része, amely felelős a kérések feldolgozásáért és kiszolgálásáért. Forrás: \cite{api}} vagy konfigurációs fájlok esetében, ilyenek például az általam használt JSON- vagy XML-formátumok,  hogy más felületekre való költöztetés esetén kompatibilitási probléma többé már ne merülhessen fel.
	
	A Marshalling primitív típusok esetén abszolút működőképes, összetett adatszerkezetekre, viszont a programok átültethetősége végett érdemes szabványos formátumokkal kommunikálni. Ha ezt elfogadjuk, akkor fontos, hogy a szerializáció és deszerializáció folyamataiba is betekintést nyerjünk.
	\section{Szerializáció}
	A szerializáció az a folyamat, amikor valamilyen adatszerkezetet bájtok folyamára\footnote{A bájtfolyam angolul byte stream néven ismert.} alakítunk, hogy. Mivel az adatok valamilyen elgondolás szerint bitekként vannak kódolva a memóriában, ezért szükségünk van a szerializáció inverz műveletére\footnote{Az eredeti művelet hatását visszafordító, visszavonó.}: ez a deszerializáció, amely folyamán az objektumot leíró bitek a programban értelmezhető, kezelhető adatokká alakulnak. Az általunk készített szoftverben JSON, valamint XML formájában mutatunk példát az adatok (szöveges) szerializálására. Ennek megfelelően egy string is lehet érvényes formátum, de nem feltétlenül muszáj ilyen költségesen leírni objektumokat. A folyamatnak létezik már egy sokkal hatékonyabb módja is, mint ezt látni fogjuk a gRPC esetében a \ref{grpc_json} fejezetben. 
	
	Abszolút jogosnak tartom felvetni azt a kérdést, hogy a programok nem eleve bitek sorozatát kezelik? Ha igen, akkor mi értelme ezt az adatfolyamot még egyszer szintén bitek sorozatává alakítani egy teljesen más eljárás mentén?
	
	Az objektumok tárolásának módját az adott nyelvhez írt, aktuális verziójú fordítóprogram, az operációs rendszer, valamint a processzor kezeli. Ha ezek közül bármelyik változik, az adattárolás formátuma ezzel együtt dinamikusan átalakul. Egy objektum szerializált változatban statikus, állandó, kód által meghatározott formátumú, amit több programnyelv is képes értelmezni és feldolgozni. 
	\cite{sof_serialization}
	\section{Marshalling és szerializáció}
	A Marshalling egy olyan folyamat, amely hidat teremt a felügyelt és felügyelet nélküli kódok között, lásd: \ref{managed_unmanaged}. A Marshalling felelős az üzenetek átviteléért managed környezetből unmanaged környezetbe, és ugyanezért visszafelé is. Ez a CLR egyik alapvető szolgáltatása. Mivel az unmanaged típusok közül soknak nincs is párja a managed környezetben, így létre kell hozni konvertáló függvényeket, amelyek oda és vissza átalakítást végeznek az üzeneteken. Ennek megvalósított folyamatát nevezzünk Marshallingnak.
	\cite{marshalling_serialization}
	\section{Adatok konvertálása}
	\subsection{Egész és valós számok, logikai változók}
	A primitívek közül numerikus értékek esetében egyszerűbb a Marshalling, mivel ezek minden nyelvben gyakorlatilag ugyanúgy vannak értelmezve.	Egyszerű adattípusok azok, amelyek nem tartalmaznak más adattípusokat. Ezek az alapjai minden más típusnak. Példák a menedzselt primitív szám típusokra: \verb*|System.Byte|, \verb*|System.Int32|, \verb*|System.UInt32|, és \verb*|System.Double|.
	\cite{marsh}
	\subsection{Szövegek}
	A szöveges unmanaged típusok Marshalling-folyamata bonyolultabb, mint a numerikusoké, mert ezek külön bánásmódot igényelnek.
	
	Az ANSI és a Unicode két olyan karakterkódolási szabvány, amelyek a legelterjedtebbek. Az ANSI-hoz képest a Unicode számít újabb kódolásnak, amelyet a modern rendszerek használnak. Amikor a számítógépek világszerte elterjedtek, nyilvánvalóvá vált, hogy az ANSI képtelen minden nemzet különböző karaktereit (példának okáért a magyar nyelvben található ékezetes betűket) kódolni, mivel a lehetséges variációk száma elfogyott, ezért az Unicode-szabványok (ide tartoznak az UTF-8, UTF-16, illetve UTF-32 néven ismert kódolások) váltották fel az ANSI-szabványt.
	
	Az ANSI legnagyobb hátránya, hogy a használt nyelvtől/régiótól függően több úgynevezett kódlapot foglal magában. Amennyiben az összes számítógép ugyanazt használja, abban az esetben nincs probléma, de ha a kódlapok eltérnek, akkor a leírt szövegek értelmezhetetlenné válnak, és bizonyos esetekben programhibához is vezethetnek. Használatuk ebből következően jelenleg már nem javasolt. \cite{ansi_unicode}
	
	A stringek alapértelmezetten BSTR-típusként (Unicode-szabványú karakterként) kerülnek fogadásra a .NET-keretrendszerben. Én a biztonság kedvéért a DLL-ben ettől függetlenül is jelzem a Marshaller számára \verb*|[MarshalAs(UnmanagedType.BStr)]|-attribútum használatával.
	
	A stringek marshalling-folyamata felügyelet nélküli (unmanaged) kód esetében így működik: egy úgynevezett \verb*|MarshalAsAttribute|-attribútumot fűzhetünk a string paraméterek, valamint visszatérési értékek elé, hogy felkészítsük a marshallert, hogy pontosan milyen típusú stringet kell várnia. Több \verb*|UnmanagedType|-érték is megadható a karakterláncok fajtájától függően.\cite{marshalling_strings}\\
	Ezek közül hármat mindenképp érdemes megemlíteni:
	\begin{itemize}
		\item \verb*|UnmanagedType.BStr| Előre meghatározott hosszúságú, Unicode-karakterkódolású szöveg található a túloldalon. Delphiben ez a WideString típusnak felel meg.
		\item \verb*|UnmanagedType.LPStr| (alapértelmezett) Egy pointer ANSI-karakterekből álló tömbre, amelyet a nullkarakter (\verb*|\0|) zár. Delphiben ez a PAnsiChar típusnak felel meg. 
		\item \verb*|UnmanagedType.LPWStr| Egy pointer Unicode-karakterekből álló tömbre, amelyet szintén a nullkarakter zár. Delphiben ez a PWideChar típusnak felel meg.
	\end{itemize}
	Ennek gyakorlati alkalmazása C\#-ban megfigyelhető a(z) \ref{string_csharp} ábrán.
	\subsection{Rekordok}
	A rekordok már az összetett adattípusok kategóriájába tartoznak, amelyek primitív és/vagy összetett adattípusokból épülnek fel. Ilyen például egy osztály (\textit{class}) vagy egy struktúra (\textit{struct}) -- C++ nyelvben megtalálható még esetleg a union is --, amelyek magukban foglalnak egyszerű vagy egyéb összetett típusokat.
	
	Az alábbi C nyelvű kódrészleten keresztül szemléltetem, hogy hogyan is néznek ki a gyakorlatban az összetett típusok. Az általam létrehozott \verb*|ListaElem| nevezetű struktúra két mezőt tartalmaz: egy primitívet\footnote{Az \verb*|uint8_t| C-ben a char, azaz a byte típussal ekvivalens, 1 bájton tárolt, előjel nélküli egész értéknek felel meg.}, valamint egy összetett típust, ami itt történetesen szintén \verb*|ListaElem| típusú, de bármilyen más rekordtípust tartalmazhatna.
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.65]{linkedlist_struct}
		\caption{Példa egy rekord definíciójára}
		\label{fig:linkedlist_struct}
	\end{figure}
	
	Lévén összetett típusról van szó, gondolhatjuk, hogy a struktúrák marshallingolása ebből fakadóan nehezebb folyamat, és ez minden bizonnyal így is van. További fejtörést okozhat például az alábbi ábrán látható Delphiben deklarált rekord típus felépítése C\# nyelvben. A probléma ebben az esetben az, hogy míg Delphiben értelmezve van a unionok\footnote{A union egy olyan adatszerkezet, amelyben bizonyos mezőkből vagy az egyik vagy a másik kerül érvényesítésre attól függően, hogy az adott rekord milyen tulajdonságokkal rendelkezik. A példában ha az eszköz -- azonosítójából fakadóan -- lámpa (vagy nyíl), akkor a \verb*|vilrgb| és \verb*|nilmeg| mezők kerülnek érvényesítésre, amennyiben viszont hangszóró, akkor a másik kettő, a \verb*|handrb| és \verb*|handtbp| mezők értékére vagyunk kíváncsiak, a két-két mező ugyanazon a memóriaterületen tárolódik, tehát egyrészt memóriát tudunk megspórolni azzal, hogy egyszerre csak az egyiket használjuk, másrészt az osztályok öröklődését helyettesíthetjük unionok segítségével. Forrás: \cite{jsorber_unions}} használata, addig C\#-ra már ez nem igaz.
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.7]{sldll_union}
		\caption{Példa egy union típus definíciójára. Forrás: SLDLL}
		\label{fig:sldll_union}
	\end{figure}
	
	A rekordok szempontjából inkább a szerializáció a nyerő stratégia, tehát ezeket az egységeket átalakítjuk egy bájtalapú adatfolyamra (streamre), amely tárolható, könnyen átküldhető valamilyen csatornán\footnote{Csatorna alatt érthetünk akár egy XML vagy JSON formátumú fájlt, akár egy stringet, akár valami más koncepción alapuló bájtfolyamot is, mint például a Protocol Buffers esetében.} keresztül, és a másik nyelv számára is átalakítható a maga nyelvi sajátosságainak megfelelően (más szóval: kódolható és dekódolható).
	Látni fogjuk, hogy a projektben én ezt úgy oldottam meg,
	\section{Managed és unmanaged kód közötti különbség}
	\label{managed_unmanaged}
	Először is fontos tisztázni, hogy a C\# szemszögéből nézve a \textit{Unmanaged Code} (nem felügyelt kód) elnevezést a .NET-keretrendszer mindenféle külső komponens megbélyegzésére használja, amelyet nem a .NET futtatókörnyezete felügyel és vezérel. Ettől még ezek lehetnek jó kódok, csak szimplán a Common Language Runtimenak nincs közvetlen hatása ezek működésére: a memóriacímeket közvetlenül lehet kezelni, felülírni, így bizonyos esetekben olyan memóriaterületre is hivatkozhat egy változó, amelyet az operációs rendszer nem a program részére foglalt le, ezt \verb*|segfault|nak nevezzük.\footnote{Másnéven \textit{access violation} hibának is nevezik, a Delphi inkább ezzel a kifejezéssel írja le a hibát.} \cite{managed} 
	
	A Common Language Runtime használatával fejlesztett kódot kezelt vagy felügyelt -- managed -- kódnak nevezzük. Más szóval, ez az a kód, amely a .NET futtatókörnyezete által végrehajtásra kerül. 
	A menedzselt kód futási környezete számos szolgáltatást nyújt a programozó számára: ilyen a kivételkezelés, típusok ellenőrzése, a memória lefoglalása és felszabadítása, így a Garbage Collection\footnote{A Garbage Collection, azaz szemétgyűjtés egy automatikusan végbemenő optimalizálási folyamat, amely során futásidő közben felszabadulnak olyan memóriaterületek, amelyek a kód korábbi részén lefoglalásra kerültek, azonban a program későbbi szakaszban már egyáltalán nem történik hivatkozás rájuk.}, és így tovább. A fent említett szolgáltatások a fejlesztőket szolgálják, hogy biztonságosabb és optimálisabb kódot készíthessenek.
	\cite{marshalling_serialization}
	
	A felügyelet nélküli kód ennek pontosan az ellentéte: pointereket kezelhetünk a kódban, ezeket tetszésünk szerint lefoglalhatjuk, felszabadíthatjuk, megváltoztathatjuk a pointer értékét (azaz más területre mutathatunk), viszont ilyen típusú kódok növelhetik alkalmazásaink teljesítményét, mivel az extra ellenőrzések ki vannak kapcsolva a kód lefutásának idejére (például egy tömb túlindexelését vizsgáló algoritmus).
	A nem biztonságos blokkokat tartalmazó kódot az \verb*|AllowUnsafeBlocks| fordítói opcióval kell lefordítani.
	
	Amikor eszközöket vezérlő kódrészleteket szeretnénk C\#-on keresztül hívni, legyen ez C++ vagy éppen esetünkben Delphi nyelven készítve, egyszerűen megkerülhetetlen a felügyelet nélküli kódok futtatása, mivel a C\#-nak ezekre ráhatásai nincsenek, nyelvi korlátokba ütköznénk, ha lámpákat és nyilakat kéne vezérelnünk C\#-forráskóddal. A .NET úgy áll ezekhez a kódokhoz, hogy ,,megengedett, de nem ajánlott'' kategóriába sorolja őket, nekünk annyit kell tennünk az ügy érdekében, hogy minél kevesebbszer hagyatkozzunk az unmanaged kódrészletekre.
	\cite{sof_managed}
	\section{Az ellenőrzött kódok előnyei és hátrányai}
	\begin{itemize}
		\item A futtatott kód biztonságosabb, erről ellenőrző algoritmusok gondoskodnak (például ilyen az \textit{array boundaries check}, ami a tömbök túlindexelését vizsgálja).
		\item A szemétgyűjtés automatikusan lezajlik, ezért nem is kell memóriaszivárgástól tartanunk.
		\item A dinamikus, azaz futásidejű típusellenőrzés biztosítva van.
	\end{itemize}
	
	Átokként és áldásként is felróható, hogy nem enged direkt ráhatást memóriacímekre: hogy a lefoglalások és felszabadítások mikor, a szekvenciának mely pontjain történnek meg, arról nem tudunk konkrét információkat, mivel a Garbage Collector ezt elrejti előlünk, a program bizonyos pontjain csak sürgetni tudjuk, hogy az optimalizálást előbb végezze el. 
	
	Ami ténylegesen hátrányként említhető, hogy nem enged hozzáférést alacsonyabb szintű részletekhez, így különböző mikrokontrollerek, hardverelemek vezérlésének szemszögéből kiindulva a programozás ezen módja nem tekinthető opciónak.
	\section{Elosztott rendszerek}
	Az elosztott rendszerek lényege, hogy van egy alkalmazás, amivel különböző kliensprogramok (ügyfelek) kommunikálhatnak, ez a szerveralkalmazás (másnéven host vagy kiszolgáló), amely legtöbb esetben egy másik számítógépen fut, amely számítógép ráadásul egy másik hálózat tagja, tehát a két gép közötti adatátvitel internetkapcsolat segítségével valósítható meg. 
	
	Az kliens és a szerver kommunikációja kétirányú: az ügyfelek többnyire kéréseket küldenek a kiszolgáló valamely erőforrásának (adatbázis) eléréséhez, a szerver is küld a kliensprogram részére üzeneteket, tájékoztatást hibaüzenetről, a végrehajtott művelet sikerességéről, annak eredményéről, és így tovább. 
	
	A szerveralkalmazás is fogadhat bizonyos adatokat a kliensektől, ezek lehetnek bejelentkezési adatok vagy éppen a felhasználó által használt kliensprogram verziószáma, elavultabb verziók esetén akár figyelmeztetheti is a felhasználót, hogy telepítse a program egy frissebb változatát. \cite{client_server}
	
	Kliens-szerver-kommunikáción alapuló alkalmazásokat különböző módokon építhetünk fel, amelyek a témám szempontjából csak annyiból fontosak, hogy például szolgáljanak programozási nyelvek közötti kapcsolatteremtés alkalmazási lehetőségeire.
	\section{Gondolataim a streamalapú kommunikációról}
	Ebben a megközelítésben a kliens és szerver kódjának nyelve megegyezik, a téma szempontjából már ez is egy tanulsággal szolgál: kell egy közös nyelv, egy szerződés a két fél között, amelytől egyik fél sem térhet el\footnote{Amennyiben valamelyik fél eltér a meghatározott szabványtól, a kommunikáció nem fog létrejönni, a kliens és a szerver nem fogja érteni egymást.}: a streamalapú kommunikáció ezt az alábbi módon valósítja meg: szövegesen eljuttatja a szerver számára a végrehajtani kívánt metódus nevét és paramétereit.
	
	Például egy kliensalkalmazásban elküldhetjük az alábbi üzenetet a streamen keresztül: \textit{"ADD|2|3"}, ezt a szerver a várakozás állapotában megkapja, rá is illeszti az üzenet első tagját -- esetünkben ez az $"ADD"$ -- az általa ismert parancsokra, és amennyiben ismeri az $"ADD"$ parancsot, meghívja rá saját $Add(int\ a,\ int\ b)$-függvényét, majd egy hasonló stream üzenetet küld vissza a kliens számára: \textit{"OK|5"}. \cite{elearning_stream}
	
	Láthatjuk, hogy van hasonlóság a küldött üzenetek között, egy szabvány, ami leírja a kommunikáció formáját. Elméletem szerint ez már önmagában nevezhető egy közös nyelvnek a kommunikációban résztvevő két fél között. 
	
	A szerver -- így a kliens is -- ismeri a következő halmaz elemeit: $$\mathbb{A} = \{"ADD", "SUB", "MUL", "DIV", "EXIT"\}$$
	Ezen halmaz elemeit véleményem szerint bátran nevezhetjük a közös nyelv kulcsszavainak, (amelyek használatával a kliens a távoli számítógép implementált metódusait hívhatjuk meg), és a résztvevő feleket ezekre feltétlenül fel kell készítenünk, hogy ezen parancsok meghívási módja, tehát az üzenetküldésre használt nyelv szintaxisa, valamint a várható eredmény ismert legyen.
	
	Ha továbbgondoljuk, a nyelv szemantikája is megadható: tegyük fel, hogy az előbb felsorolt parancsok használatához szükség van bejelentkezésre. Bejelentkezik $$"LOGIN|username|password"$$ üzenettel a szerverre, amely eldönti, hogy a bejelentkezési adatok passzolnak-e az általa eltárolt felhasználói rekordok bármelyikével, amennyiben igen, bejelentkezteti a felhasználót a szerverre. Ekkor már a többi parancs is megnyílik a számára, a $"LOGIN"$ letiltásra kerül. Ha a bejelentkezést követően a felhasználó ugyanazon parancsot ismételten kiadná, kapna a szervertől egy $"ERROR|ALREADY\_LOGGED\_IN"$ üzenetet.
	
	Szintaktikailag\footnote{\textbf{Szintaxis :} Programozásban az elgépelt kulcsszavak, azonosítók, az idézőjelek és zárójelek helytelen használata, és így tovább.} ugyan helyes parancsot adott ki a felhasználó -- azaz az általa futtatott kliensprogram --, de már a parancs meghívása ebben a kontextusban (ebben a párhuzamban kontextusnak számíthatjuk a sessiont)\footnote{Egy többfelhasználós rendszerben munkamenetnek (session) nevezzük azt az időszakot, ami eltelik a felhasználó be- és kijelentkeztetése között, ekkor az szabadon végezheti a dolgát, nem kell minden egyes funkció használatához bejelentkeznie.} már egyszer megtörtént, így a megkapott hibaüzenetben tulajdonképpen egy \textit{szemantikai hibáról}\footnote{\textbf{Szemantika (jelentéstan)}: Programozási nyelvek terén ez azt jelenti, hogy kifejezéseket vizsgálhatunk, hogy annak az van-e értelme az adott kontextuson belül. Például amikor egy 'i' nevű változónak növeljük az értékét (\textit{i = i + 1} vagy \textit{i++}), viszont 'i' korábban nem volt definiálva, akkor \textit{szemantikai hibáról} beszélünk.}
	
	\section{RESTful alkalmazások}
	\label{rest}
	A szerver-kliens-architektúrák megvalósításának egyik legnépszerűbb módja egy RESTful alkalmazás készítése. A szerver különféle erőforrásai (adatbázisban lévő táblák, az ezeket módosító függvények) különböző Unified Resource Identifiers (URI) címeken keresztül érhetőek el. A kliensnek elegendő ezen URI-címek valamelyikét meghívni, a hívással egy kérést intéz a szerver felé, majd az valamilyen szabványos szöveges formátummal -- ilyen például a JSON is -- képes visszaküldeni a kérés eredményét a kliensprogram számára.
	
	\section{Google RPC és a Proto-nyelv}
	\label{grpc}
	A Google RPC, röviden gRPC a Google jóvoltából készült nyílt forráskódú RPC-keretrendszer. Remote Procedure Callnak\footnote{magyarul: Távoli eljáráshívás} nevezzük, amikor $A$ processz meghívja $B$-nek valamely meghirdetett szolgáltatását, így $B$ a kért műveletet implementációja szerint elvégzi, majd $A$ részére visszajuttatja az általa kért művelet eredményét. Így $A$-nak nem kell törődnie a végrehajtott algoritmus részleteivel, ennek implementációja és futtatása $B$ részére delegálódik. Ez lehetőséget teremt arra, hogy bizonyos kódrészleteket, implementációkat egy másik számítógépre, egy szerverre helyezzünk át, ettől lesz a hívás ''távoli''.
	
	Hogy az RPC-t jobban megértsük, gondoljunk egy távirányítóra: a távirányítóval képesek vagyunk távolról vezérelni a televíziót, be- és kikapcsolhatjuk, csatornát válthatunk a segítségével, változtassunk annak hangerején, és így tovább. A távirányító a televízió azon tulajdonságait tudja elérni, amelyek számára ''meg vannak hirdetve'', azaz amely gombokra reagál a tévékészülék. A tévé által meghirdetett szolgáltatásait meg tudjuk hívni távirányítón keresztül. A ''távoli hívás'' segítségével elértük, hogy ne kelljen minden alkalommal fizikailag közel lennünk a készülékhez, amikor annak beállításain módosítani kívánunk. Ugyanakkor a távirányító használata alternatív megoldásként is szolgál olyan esetekre, amikor fizikai interakció nem vagy nehezebben kivitelezhető, például meghibásodott a nyomógomb, vagy éppen túl magasan helyezkedik el a televízió.
	
	A gRPC-t számos programozási nyelv támogatja, a teljesség igénye nélkül ezek a Java, C\#, C, C++, Kotlin, Python és PHP-nyelvek. Még Delphiben is létezik egy külső komponens, amit a projekthez hozzáadva használhatjuk a gRPC nyújtotta szolgáltatásokat. \cite{grpc_delphi}
	
	A keretrendszer működtetője az úgynevezett \textit{Protocol Buffers}, amely nyelv- platformfüggetlen adatcserét biztosít. A gRPC-ben ennek a segítségével teremthetünk kapcsolatot különböző vagy azonos programozási nyelven készített alkalmazásaink között, egy szerveralkalmazáshoz különféle platformokra írt kliensprogram is kapcsolódhat, mivel a kérések és válaszok nyelvezete közös, szabványos. 
	
	Ami weboldalaknál a HTML, az a gRPC esetén a Proto-nyelv, ami átjárást biztosít más nyelven írt programok részére is. Amely nyelv képes implementálni a gRPC-t, a Proto-nyelvből le tudja gyártani maga forráskódját, valamint a forráskódjából is generálható a Proto-formátum, az alkalmas ezen a nyelven keresztül összekapcsolódni más, ugyanezt a keretrendszert alkalmazó szerverprogrammal is. A Proto-nyelv választott témám szempontjából kifejezetten lényeges, mivel pontosan arra a célra lett kitalálva, hogy programozási nyelvek felett álljon, ezért úgy gondolom, érdemes tovább vizsgálnunk a nyelvben rejlő lehetőségeket.
	
	De miért kell ehhez egy külön nyelv? Nem maradhatunk a jól bevált formátumoknál, amilyen a JSON is? A Proto-nyelv olyan előnnyel jár, amelyeket sem a JSON, sem az XML, sem bármilyen más szerializált formátum nem tud biztosítani: az adatszerkezeteket szigorúan típusosan írja le. Ezenkívül nemcsak adatszerkezetek, hanem szolgáltatások -- azaz metódusok szignatúrájának -- leírására is egyaránt alkalmas a Proto-nyelv, ezért is lehet érdemes az RPC ezen megközelítését használni, mivel nagyobb lehetőséget biztosít a kommunikációra, mint az előbb felsorolt opciók.
	\begin{figure}[h]
		\centering
		\includegraphics[scale=0.45]{protobuf}
		\caption{Beadandó projektben készített .proto állomány (részlet)}
		\label{fig:protobuf}
	\end{figure}
	
	Lényegében elég a fentebb látható .proto kiterjesztésű fájlt elkészítenünk, ennek környezetét, a kliens- és szerveroldali stubok forráskódjának vázát az adott nyelv szabályrendszere szerint képes lesz legyártani ebből. Ennek lehetősége a legtöbb RPC-keretrendszernél nem áll fenn.
	
	Mint azt említettem, Proto-nyelvben a változókat csak típussal együtt vehetünk fel\footnote{Ezen tulajdonsága miatt a Proto szigorúan típusos nyelvnek számít.}, osztályokat \verb*|message|, a meghívható metódusokat a kifejezőbb \verb*|rpc| kulcsszóval látja el. Mint láthatjuk, a mezők nevéhez 1-től kezdődően számokat rendelünk, ez a szerializációhoz szükséges. Binárisan ez úgy fog kinézni, hogy a mező azonosítóját annak típusával kombinálják, ezzel lényegében egy mező leírásához pusztán 1 bájtnyi terület elegendő. Ha üzeneteinket úgy szervezzük, hogy azonosítókat 1-től maximum 15-ig terjedően oszthatunk ki (tehát legfeljebb 15 mezőt engedünk meg osztályonként), akkor ez a tulajdonság garantált. 
	
	Az adatokat a Protocol Buffers használatával a lehető legtömörebb bináris formátumban tudjuk leírni és továbbítani a hálózaton, a JSON-formátum ezzel szemben egy az egyben szövegesen kerül átadásra, ami jóval több adatforgalmat tesz ki. Természetesen ez is előnyös a gRPC részére, hogy ugyanaz az adat, amit szövegesen közölnénk, tömörebb formában kerül átadásra szervertől kliensig, és fordítva. Ennek használatával véleményem szerint csökkenthetjük az adatforgalmat, és növelhetjük a szerver kapacitásait, mivel annak egyetlen kérés kiszolgálására kevesebb energiát kell fordítania.
	
	Emellett nyugodtan kijelenthetjük, hogy ez a megoldás típusbiztonsági szempontból is előnyösebb, mivel a Proto-nyelvet használva a mezőket eleve típusokkal kötjük, így nem az érkezés helyein kell validálni a megérkezett adatokat. Szöveges szerializáció esetében minden alkalommal, amikor például JSON érkezik, elsősorban ellenőriznünk kell, hogy a fogadott JSON-stringben az értékek típusai rendre megegyeznek-e az osztályban definiált mezők típusaival. Ez a Proto-nyelv esetében automatikusan teljesül, mivel a típussal kapcsolatos hibák már a küldéskor kiütköznek.
	
	Az adatokat a lehető legtömörebb bináris formátumban képes leírni és szállítani a hálózaton, a JSON-formátum ezzel szemben egy az egyben szövegesen kerül átadásra, ami jóval több adatforgalmat tesz ki. \cite{grpc_rest}
	\subsection{Jobb a Proto a JSON-formátumnál?}
	Ezt a kérdést árnyalja, hogy gRPC használatával négyfajta metódushívást tudunk leírni, ezeket érdemes megvizsgálni:
	\begin{itemize}
		\item \textit{Unáris hívások}: Itt egyszerű kérés-válasz-üzeneteket cserélünk. Ez Protoban úgy néz ki, hogy a szolgáltatások paramétere és visszatérési értéke is message típusú. Például az alábbi ábra szerint a legelső, \verb*|Login|-függvény egyetlen \verb*|User|-objektumot\footnote{a gRPC kontextusában ez message néven ismert} vár, majd ez a függvény egyetlen \verb*|SessionID|-objektummal tér vissza.
		\item \textit{Kliens streamelés}: A kliens egy adatfolyamot -- gyakorlatban ez egy lista -- küld paraméterben a szerver részére, a kiszolgáló pedig egyetlen objektummal (message) tér vissza. Erre példa az ábrán látható harmadik függvény, az \verb*|Adopt|, amely a gyakorlatban annyit jelent, hogy a kliens egy kérésben több állatot, állatok listáját képes örökbe fogadni. A szerver erre a kérésre egyetlen \verb*|Result|-objektummal válaszol.
		\item \textit{Szerver streamelés}: A kliens elküld egy kérést, és a szervertől válaszként streamet fogad. Erre például szolgál az ábra második függvénye, amelyben a kliens lekéri az összes állatot tartalmazó listát a szervertől, hogy azokat a felhasználó számára megjeleníthesse. A szerver minden esetben egy listával, egy streammel fog válaszolni, legyen az üres, egyelemű vagy többelemű.
		\item \textit{Kétirányú streamelés}: A kliens és a szerver is streamben kommunikál egymással. Például azt mondjuk, hogy az állatok listájából egyszerre több szűrési feltétel megengedett, az állat telephelye és faja szerint is végezhetünk szűrést. Ekkor a kliens szűrések listáját küldi el, és a szerver olyan állatok listájával tér vissza, amelyekre a szűrési feltételek egyszerre teljesülnek. Ezt mutatja az ábra 4. metódusa.
	\end{itemize}
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.75]{grpc_calls}
		\caption{gRPC metódushívásainak típusai}
		\label{fig:grpc_calls}
	\end{figure}
	\label{grpc_json}
	Az alábbi ábrán látható, hogy a bináris szerializációt alkalmazó Proto-kérések futásidőben sokkal gyorsabbnak bizonyultak, mint a JSON-t használó REST-hívások, a kísérlet győzteseként a \textit{kliens streamelés} került ki (63.25 ezredmásodperccel), ami körülbelül 13-szor gyorsabb, mint a leglassabb REST-módszer (792.51 ms), és legalább 5-6-szor gyorsabb, mint egy átlagos REST JSON-hívásokkal. A másik két gRPC-hívás (Unáris és kötegelt\footnote{A \textit{batch}, azaz kötegelt programozásban nagy mennyiségű adatot kötegelt formában dolgozunk fel. Az adatok egy bizonyos időszakban összegyűlnek, majd ezek feldolgozása egy menetben történik. Ilyen például a bérszámfejtés, ami megvárja, hogy egy munkás munkaórái összegyűljenek a hónap során, majd a hónap lezárultát követően a megadható munkabért meghatározza. Forrás:\cite{batch}} kliens streamelt hívás 63.39 ms és 69.52 ms eredményekkel) is hasonlóan teljesítettek, és pár ezredmásodperccel maradtak le az első helyezetthez képest.
	\cite{grpc_performance}
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.2]{grpc_json}
		\caption{Szerializáció teljesítményének összehasonlítása JSON és Proto esetében}
		\subcaption{Forrás: \cite{grpc_performance}}
		\label{fig:grpc_json}
	\end{figure}

	\subsection{DLL-ek üzenetküldése Win32-ben}
	A DLL (Dynamic-Link Library) egy forráskódokból előállított, gépi kódra lefordított könyvtár, amely olyan kódokat és adatokat tartalmaz, amelyeket egyszerre akár több program is használhat. Ebben a tekintetben az én meglátásom szerint a DLL egyfajta ''helyi szerverként'' is felfogható, amelynek meghirdetett, hívható szolgáltatásai (metódusai) vannak, valamint a benne tárolt adatokon műveletet végez. A DLL azonban csak Windows operációs rendszereken hívható segítségül, például a különböző Linux-disztribúciók számára ez ismeretlen, ezek a .so (shared object) kiterjesztésű fájlokat használják ugyanerre a célra.
	
	Egy üzenetlistán\footnote{A Message Queue (üzenetsor) egy sor (queue) adatszerkezetben, érkezési sorrendben tárolja az üzeneteket, majd ezek ugyanezt a sorrendet megtartva kerülnek le róla.} keresztül kommunikál az operációs rendszer a futó programmal, ezt projektünk szempontjából Levente ablakos alkalmazása fogja jelenteni. Az operációs rendszer ráteszi a lenyomott gomb által kiváltott üzenetet erre a listára, tehát például amikor az egér bal gombjával kattintunk, akkor azt ténylegesen nem a futó program fogja észlelni, mivel az operációs rendszer a központ, ahova az I/O-kérések befutnak. 
	
	Az operációs rendszer eleve azért felelős, hogy elossza az erőforrásokat és kezelje a kimeneti-bemeneti perifériákat, így az egerünk által kiadott jel is az operációs rendszerhez érkezik be.
	Az alábbi lépéssorozat fog lejátszódni:
	\begin{enumerate}
		\item Az operációs rendszer ráteszi a \verb*|WM_LBUTTONDOWN|-üzenetet az üzenetsorra.
		\item A programunk meghívja a \verb*|GetMessage|-függvényt.
		\item A \verb*|GetMessage| leveszi a \verb*|WM_LBUTTONDOWN|-üzenetet az üzenetsorról, és az érkező információkból feltölti a \verb*|Message|-adatszerkezetet.
		\item A programunk meghívja a \verb*|TranslateMessage|- és \verb*|DispatchMessage|-függvényeket, utóbbiban az operációs rendszer meghívja az asztali alkalmazás \verb*|WndProc| függvényét. Ez minden esetben lezajlik, attól függetlenül, hogy a függvény ki van fejtve vagy sem.
		\item Az ablakos alkalmazásban válaszolunk az I/O-kérésre (például egy gombra kattintva újabb ablakot nyitunk meg) vagy éppen figyelmen kívül is hagyhatjuk, ekkor a felhasználó belátja, hogy lényegében nem is történt semmi.
	\end{enumerate}
	
	Már az is Win32-üzenetet vált ki, ha szimplán mozgatjuk az egerünket, ekkor az egér új pozíciója is az üzenetben tárolásra kerül, innen és a Form előre meghatározott tulajdonságaiból (ablak pozíciója, szélessége és magassága) tudjuk detektálni például, hogy az egér az ablak területére érkezett.\footnote{Erre vonatkozó esemény a \verb*|MouseEnter|-event Windows Forms esetében.}
	
	Ha erre a felhasználói bemenetre fel van készítve a programunk által üzenetküldésre használt metódus\footnote{Egy-egy Win32-üzenet feldolgozását Windows Form asztali alkalmazás esetében a \verb*|WndProc|-metódus szolgálja.}, akkor az érzékeli, hogy erre az eseményre reagálnia kell, így egy másik állapotba lép. Természetesen a készített programban lehetőségünk van arra is, hogy egyszerűen ignoráljuk az operációs rendszer felől érkező üzeneteket.
	
	A felhasználó ebből az egész folyamatból csak annyit érzékelhet, hogy a lenyomott gomb hatására valami esemény történt a programban, így ő azt gondolhatja, hogy közvetlenül a program érzékelte az interakciót. Lényegében ez is történik, csak az operációs rendszer végzi az I/O-eszközökről érkező jelek feldolgozását, és erről egy Win32-üzenet formájában tájékoztatja az éppen futó asztali alkalmazást is.

	\subsection{Szakdolgozati munkánkról}
	\subsubsection{A vezérelni kívánt eszközök}
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.45]{images/foto_lampa.jpg}
		\caption{SLDLL segítségével vezérelhető lámpa típusú eszköz}
		\label{fig:foto_lampa}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.45]{images/foto_nyil.jpg}
		\caption{SLDLL segítségével vezérelhető nyíl típusú eszköz}
		\label{fig:foto_nyil}
	\end{figure}

	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.45]{images/foto_hangszoro.jpg}
		\caption{SLDLL segítségével vezérelhető hangszóró típusú eszköz}
		\label{fig:foto_hangszoro}
	\end{figure}

	\subsubsection{Csatlakozók, átviteli eszközök}
	Speciális, két eres (2 position, 2 contact, azaz 2p2c) telefonkábel két végére RJ9-es csatlakozókat krimpeltünk, ezzel kapcsolhatjuk össze az eszközöket, amelyek a programban egyetlen tömbben lesznek kezelve.
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.65]{images/foto_rj9.jpg}
		\caption{Telefonkábel RJ9 csatlakozókkal}
		\label{fig:foto_rj9}
	\end{figure}	
	
	Nyomatókábel USB-A és USB-B végekkel, előbbi a számítógéphez, míg utóbbi az elsőnek szánt eszközhöz csatlakoztatandó:
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.65]{images/foto_usbab.jpg}
		\caption{Nyomtatókábel USB-A és USB-B csatlakozókkal}
		\label{fig:foto_usbab}
	\end{figure}		
	
	Tápkábelt használunk a további, számítógéphez csak közvetve nem csatlakozó eszközök feszültségre kapcsolásához:
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.65]{images/foto_tapkabel.jpg}
		\caption{Tápkábel a csatlakozókkal}
		\label{fig:foto_tapkabel}
	\end{figure}

	Ezen dokumentum mellé készített szakdolgozati szoftverprojektemet Sipos Levente hallgatótársam részére, az ő feladatának megkönnyítésére készítem. 
	Munkám arról szól, hogy Delphiben implementált metódusokat lehessen meghívni a .NET-keretrendszerből, ennek lehetséges módját kutassam. A C\# és Delphi programozási nyelvek összehangolása az én feladatom, az elkészült termék úgynevezett segítő, azaz helper metódusok implementációit tartalmazó, lefordított\footnote{Lévén a C\# fordított nyelvnek számít, ezért az alkalmazások futtatásához/használatához az elkészült forráskódokat első lépésben futtatható állományra (gépi kódra) kell fordítani egy fordítóprogram segítségével. Ezt a folyamatot szakszóval \textit{compilingnak} vagy \textit{buildelésnek} is nevezzük.} DLL-projekt lesz, amelyeket Levente az ő Windows Forms keretrendszerrel készített grafikus alkalmazásában tud meghívni. Továbbá szükség volt egy úgynevezett relayDLL-re, amelyet én állítottam össze.
	
	\section{Miről is szól munkánk?}
	Egy mentális egészségfejlesztésre használatos alkalmazást fejlesztésére vállalkoztunk 2022 szeptemberében, amely elméleti alapjait Somodi László futballedző munkásságának köszönhetjük, ezek gondolati vonulatairól titoktartási szerződésünk lévén csak nagyon érintőlegesen fogok beszámolni a későbbiekben. 
	
	A készített alkalmazásunk gyakorlatilag különböző fény- és hangjelzések kibocsátására alkalmas eszközök (lámpák, nyilak és hangszórók) vezérléséből áll, egy úgynevezett \emph{intelligens szobában} az eredeti tervek szerint 8 eszköz (a készített program azonban tetszőleges, $n$ darabszámú eszköz vezérlésére lett felkészítve) együttes vezérlését kell kezelnünk megadott időközönként, amely időközöket egyszerűen ütemnek fogjuk nevezni.
	A módszer alkalmazása az intelligens szobával együtt működik teljességében.
	
	\section{Mit jelent az intelligens szoba?}
	Az intelligens szoba elnevezés olyan helységet takar, amelynek mind a négy falán jeladókat helyeztünk el.
	Ezek különböző típusú eszközök: fények, nyilak és hangok. 
	Ezek különállóan vagy együttesen jeleket küldenek, amely jelekre speciális mozdulatokat kell a foglalkoztatottnak végrehajtani.
	Az eltérő színek más feladatokat írnak le, mást kell tenni piros, és szintén mást zöld szín felvillanása esetén, ez emlékeztetheti az embert a forgalmi jelzőlámpák működésére is: minden színhez más jelentést rendelhetünk. A nyilak felvillanásának és a hangszóróból érkező különféle hangok észlelése esetén pedig irányváltásokat kell végezni.
	
	Egy feladatsor több egymást követő ütemből áll, mely a programban azt fogja jelenti, hogy x másodperc késleltetéssel a felmért eszköz tömb elemeinek tulajdonságait (mezőit) a feladatsor aktuális ütemének megfelelően módosítjuk. Mivel minden eszközt együttesen vezérlünk, a program ütemenként az összes eszköz állapotát felül fogja írni, ezért szükségünk van egy olyan állapotra is, ami azt közli az adott eszközzel, hogy éppen semmit ne csináljon (azaz várakozzon). Ez a fényeszközök esetében egyszerűen (0,0,0) RGB-színkód\footnote{Az RGB-színkódolás egy szín leírását három komponens, vörös (\textbf{R}ed), zöld (\textbf{G}reen) és kék (\textbf{B}lue) alapszínek arányától teszi függővé.} közlését, míg hangeszköz esetén egy 0 dB hangerősségű tetszőleges frekvenciájú hangjelzés kiküldését fogja jelenteni.
	Somodi László edzővel való együttműködésünk Dr. Király Roland Egyetemi Docens Úr jóvoltából jöhetett létre, akinek az alkalmazással kapcsolatos múltbéli tapasztalatait és  ötleteit folyamatos egyeztetések, konzultációk útján tudtuk segítségül hívni.
	\section{Delphi és C\# nyelvek összehasonlítása}
	Először is érdemes leszögeznünk, hogy a továbbiakban Delphi alatt nem a fejlesztői környezetet, amely az Object Pascal nyelvvel dolgozott együtt, hanem inkább a programozási nyelvet értjük, jelenleg az Object Pascal megnevezés úgynevezett ,,umbrella term'' formájában él tovább.\footnote{Az umbrella term (magyarul gyűjtőfogalom) olyan kifejezés, amely több fogalmat rendel önmaga alá, így már fogalmak egy csoportját, kategóriáját jelenti összefoglalóan.} \cite{sof_delphi}
	A Delphi nyelv (megjelenési éve: 1986, a Borland nevű cég jóvoltából) idősebb nyelvnek számít a C\#-hoz (megjelenési éve: 2001, a Microsoft 
	jóvoltából) viszonyítva, ebből fakadóan egy kiforrottabb, stabilabb eszköznek számít a programozók kezében. 
	
	Mindkét nyelv \textbf{objektumorientált}, ami azt jelenti, hogy bizonyos, logikailag összetartozó adatokat (mezőket), valamint a rajtuk végezhető műveleteket (metódusokat) egy egységbe zárunk, ezt az egységet a továbbiakban osztálynak nevezzük. Az osztály mezőit és metódusait különböző láthatósági szintekkel vértezhetjük fel, ezzel védhetjük az osztályunk kritikus részeit más osztályokkal szemben. Az osztályok között akár öröklődéssel, akár objektum-összetétellel kapcsolatokat alakíthatunk ki.
	
	A két nyelv \textbf{erősen típusosnak} számít, mivel egy változó definiálásakor meg kell mondanunk azt is, hogy milyen típusú értékeket szeretnénk abban tárolni, a típusok már a forráskódban explicit módon megjelennek, így az adott nyelv fordítóprogramja fel van készítve a változó típusaira, amely változó hatókörén belül nem is változhat meg. Hatókör, illetve \textit{scope} alatt a program azon részét, kontextusát értjük, amely magában foglalja az adott változót. Ezen kontextuson belül a változó ''életben van'', tehát a memóriában hely van lefoglalva számára, nevére és/vagy memóriacímére hivatkozva értékét felülírhatjuk, kiolvashatjuk. A változó típusa meghatározza, hogy az értéket hogyan kell értelmezni a memóriában, a megadott típusnak mely műveletei vannak értelmezve, így például egy \verb|string| típuson nem értelmezhetünk logikai ÉS (konjunkció)-műveletet.
	
	Az elkészült kódok teljesítménye alapján is érdemes összehasonlítani a két nyelvet. Ehhez először is külön kell választanunk a fordításhoz és a futtatáshoz szükséges időt, lévén ezek fordított (nem interpretált) nyelvek, ezért ezek nem szimultán módon, nem egyszerre történnek. A Delphi fordítóprogramja azonnal gépi kódot\footnote{A gépi kódban már az utasításokat is számok jelzik, ezen nyelv utasításkészlete már a számítógépben működő processzor típusától is erősen függ. Gépi kód általában véve fordítóprogram eredménye, a hardverközeli vezérlőprogramok elkészítéséhez is inkább az eggyel magasabb szinten lévő Assembly nyelvet használják.} készít, míg a C\# esetében első lépésben egy köztes nyelvű\footnote{A(z) (Common) Intermediate Language a .NET-keretrendszerben a magasabb absztrakciós szintű C\# és a legalacsonyabb gépi kód között ,,félúton'' helyezkedik el, ami még processzortól és operációs rendszertől független. A .NET Runtime futtatókörnyezete képes futtatni.} kód készül, amelyet a .NET virtuális gép képes futtatni. Bár fordítási időben a Delphi-kód abszolút győztesnek tekinthető -- mivel fordítóprogramja közvetlenül futtatható állományt készít --, a két nyelv segítségével készített programok futásideje közel azonos. Így megállapítható, hogy mérvadó teljesítménybeli különbséget kizárólag a fordítás folyamatában észlelhetünk.
	
	Ha ennél is tovább megyünk, akkor a C\#-nak nagy előnye származik abból a Delphivel való összevetésben, hogy aszinkron\footnote{ Az aszinkron programozás lehetővé teszi, hogy az alkalmazás egy időigényes folyamat futtatását háttérbe helyezze, így a programot futtató szál, lévén nem várakozik a válaszra, addig ugyanúgy képes a felhasználói interakciókat kiszolgálni.} kódolási lehetőséget is biztosít, amely felgyorsítja a végrehajtást, jobban ki tudja használni a rendelkezésre álló CPU teljesítményét.\cite{async}
	A LINQ\footnote{A Language Integrated Query (magyarul: nyelvbe ágyazott lekérdezés) egy gyűjtőfogalom a C\# nyelvbe épített szintaktikai elemekre, amely elemek lehetővé teszik, hogy akár lambda kifejezésként, akár SQL-szintaxishoz hasonló módon meg tudjunk fogalmazni lekérdezéseket bizonyos - iterálható, vagyis bejárható, az IEnumerable-interfészt megvalósító - szerkezetekre.} használata \verb|yield| kulcsszóval az iterációkban biztosítja, hogy csak akkor van végrehajtva a kód, amikor valóban szükség van rá (lusta kiértékelés). A delegate-ek használata tovább növelheti a C\#-kódok teljesítményét, bár a Delphi is rendelkezik ehhez hasonló funkciókkal.
	\cite{perf_comp}
	
	A fejlesztés folyamán elkészített \textbf{modulokra} a különböző programozási nyelvek eltérő megnevezéseket használnak.\footnote{Az említett példákon kívül a Java-nyelvben \textit{package}-ként, míg a Pythonban \textit{module}-ként hivatkoznak az osztályokat összegyűjtő egységre.} A vizsgált két nyelv tekintetében is ez áll fenn: a C\# \verb|namespace|, míg a Delphi \verb|unit| kifejezéssel illeti, a lényegük ugyanaz lesz: 
	\begin{enumerate}
		\item \textbf{Elnevezések}: Mivel előfordulhat, hogy két, funkciójában eltérő osztálynak ugyanazt a nevet kellene adnunk, nem tehetnénk meg, mivel a fordítóprogram nem tudná eldönteni, hogy a két változat közül éppen melyiket kívánjuk érvényesíteni. Ezt a problémát orvosoljuk például a kódok modulokra való felosztásával.
		
		\item \textbf{Egységbe zárás}: A modulok lehetővé teszik a programozók számára, hogy egy funkcionalitás végrehajtási részleteit kapszulázzák és elrejtsék. Ez azt jelenti, hogy a modulok tiszta felületet biztosítanak a funkcionalitással való interakcióhoz, miközben a mögöttes kódot elrejtik és védik a véletlen változásoktól.
		
		\item \textbf{Újrafelhasználhatóság}: A kód modulokba történő kapszulázásával a programozók olyan kódot hozhatnak létre, amely több programban is felhasználható. Ez csökkenti a fejlesztési időt és erőfeszítéseket azáltal, hogy a programozók újra felhasználhatják a már megírt és tesztelt kódot.
		
		\item \textbf{Karbantarthatóság}: Ha a kódot modulokba szervezik, könnyebb karbantartani és frissíteni, mivel az egyik modulban anélkül lehet változtatásokat végrehajtani, hogy az befolyásolná az azt használó többi modult. Ez javítja a kód karbantarthatóságát és csökkenti a hibák bevezetésének valószínűségét.
		
		\item \textbf{Moduláris felépítés}: A modulok használatával kódjainkat több kisebb, könnyebben kezelhető darabra szedhetjük szét. Ez megkönnyíti a kód megértését, és mivel a komponensek így külön fájlokban találhatóak, így a kódot szimultán módon a fejlesztőcsapat több tagja is fejlesztheti.
		
		\item \textbf{Importálhatóság}: A modul legyen beemelhető más komponensbe, ehhez szükség van egy olyan összefoglaló névre, amire hivatkozni tudunk, amikor a modult használni szeretnénk máshol is.
		
		Összességében a modulok használata a modern programozás alapja, mivel segítségükkel kódjaink a későbbiekben felhasználhatóak több helyen is, karbantartásuk gyorsabb és egyszerűbb. A programozók a programokat önálló darabokra tervezik, amelyeket meg tudnak írni, majd akár el is felejthetik egy-egy komponens belső működését, tehát hogy a problémára adott megoldás hogyan lett megoldva, elég csak azzal foglalkozniuk, hogy mi az a problémakör, amit a program ezen szelete lefed. \cite{delphi_basics}
	\end{enumerate}
	
	Ami közös még a két nyelvben, hogy a fejlesztés moduljaiból Win32-szabványnak megfelelő DLL-ek készülhetnek a segítségükkel. Ezek lefordított, gépi kódú állományok, amelyek más szoftver forráskódjában felhasználhatóak, lényegében a felhasználáskor, futásidőben válnak futtatható állománnyá Windows operációs rendszerek esetében.
	
	\section{Miket tud a C\#, amit a Delphi nem?}
	\begin{itemize}
		\item automatikus memóriakezelés - Garbage Collector gondoskodik a memória felszabadításáról futásidőben.
		\item lambda kifejezések és LINQ: A LINQ, vagyis a Language-Integrated Queries -- nyelvbe ágyazott lekérdezések -- a C\# 3.0 nyelv és keretrendszer újdonsága, amely használatával egyszerűbb szintaxissal végezhetünk tömbökön, listákon, és adatbázisokon egyaránt lekérdezéseket. A típusellenőrzést a .NET fordítási időben végzi. A lekérdezések egymáshoz láncolhatóak, tehát egyetlen utasítással egészen összetett szűréseket tudunk végezni letárolt adatainkon. \cite{linq}
	\end{itemize}
	\section{Miket tud a Delphi, amit a C\# nem?}
	\begin{itemize}
		\item Alacsonyabb szintű, Assembly nyelvű kódokat is futtathatunk Delphi-kódból, ez történik a programunkban használt SLDLL-állományban is.
		\item \emph{Case insensitive}, azaz a kód nem érzékeny kis- és nagybetűre, ezért a változók, a különböző kulcsszavak, metódushívások leírhatóak tetszőleges formátumban.
		\item Az utasításblokkok határait a \verb*|begin| és \verb*|end| kulcsszavak jelzik, így azok megléte vagy hiánya könnyebben észrevehető.\cite{pascal_csharp}
	\end{itemize}
	\section{Alaphelyzet}
	Amikor a munkát megkezdtem, rendelkezésemre állt egy Delphis asztali alkalmazás, amelyet Dr. Király Roland Egyetemi Docens Úr által fejlesztett, és -- mint kiderült -- a mai napig teljes mértékben használható. Ezen alkalmazás forráskódjában követtem végig az hardvereket működtető függvények hívási sorrendjét (szekvenciáját), a hívások módját és eredményeit, végül az esetlegesen előforduló hibaüzeneteket. 
	Ezen alkalmazás C\#-nyelvű megfelelőjének elkészítését, az alapprogram továbbgondolását kaptuk feladatként Leventével. 
	
	\section{Az SLDLL-függvények bemutatása}
	A következőkben a Keresztes Péter Tanár Úr által Delphiben implementált metódusokat, ezek kezelésének lehetőségeit fogom részletezni.
	Általánosságban elmondható, hogy minden függvény egész típusú értékkel tér vissza, amely érték tájékoztat a lefutás eredményességéről: amennyiben a hívott metódus sikeresen (hiba, kivétel nélkül) lefutott, 0-val tér vissza, ahogy ezt egyébként az operációs rendszerek processzeinél is megszokhattuk. Ettől eltérő értékek az egyes hibatípusokat hivatottak meghatározni a Win32-szabvány\footnote{A Win32-es hibakódok szabványa szerint minden hibakódnak a $0x0000$ (decimálisan: 0) és $0xFFFFFF$ (decimálisan: $16\,777\,215$) közötti tartományban kell lennie.} keretein belül. Ezen hibakódok projektünkre vonatkozó részét az alábbi táblázatban \ref{fig:errcodes} összegyűjtöttem. \cite{errcodes}
	
	A DLL, miután használatba vettük, az \verb*|SLDLL_Open| hívásakor paraméterben megadott címre (A Form Handle mezője) küldött Win32-üzenetekkel tartja a kapcsolatot a felhasználóval (hívó féllel). Az üzenet (Message) WParam értéke tartalmazza minden esetben a lefutás sikerességéről szóló információt.
	Ha az üzenethez tartozik más adat akkor arra a Win32-üzenet LParam értékével hivatkozhatunk. Ilyen esettel \verb*|SLDLL_Listelem| függvény hívásakor találkoztam, amikor az eszközök darabszámát tároló változónak adtunk értéket (drb485).
	
	Az egyes funkciók visszatérési kódja tájékoztat a hívás sikeres vagy sikertelen voltáról. Ha a visszatérési kód \verb*|NO_ERROR| (0), akkor a hívás sikeres volt. A lehetséges értékek az adott hívás dokumentációjában ismertetésre kerülnek SLDLL esetében.
	
	\subsection{Open -- DLL megnyitása}
	A program azzal nyit, hogy felméri az USB-porton csatlakoztatott, egymással telefonkábellel\footnote{A telefonkábel egy sajátos változatát használtuk, mivel a benne található 4 érből pusztán a középső kettőt vettük igénybe, a két szélső eret ki kellett iktatnunk annak érdekében, hogy azok a soros kommunikációt ne zavarják. A kábelek végeit RJ9 szabványú csatlakozókkal zártuk le, az eszközök a csatlakozóknak megfelelő portokon keresztül lettek egymáshoz kapcsolva.} összekapcsolt eszközöket, ezeket egy-egy azonosítóval látja el, hogy külön-külön vezérelni tudjuk őket. 
		
	A program indulásakor legelőször lefutó \verb*|SLDLL_Open|-függvényt meghívva elkezdhetjük az SLDLL további metódusainak használatát. A hívást érdemes kódból elvégezni, ennek kezelését nem kell a felhasználóra bíznunk, mivel egyrészt elfelejtheti, másrészt felesleges, hogy a felhasználó tudjon a kötelező metódushívási sorrend betartásáról. 
	
	A függvény továbbá elvégzi a Form felcsatlakoztatását a Win32 üzenetküldési láncra a paraméterben kapott Handle memóriacíme alapján, innentől a DLL üzenetküldésre is alkalmas az asztali alkalmazásunk részére. Tervben volt részünkről egy Delphiben írt konzolos alkalmazás elkészítése is, amely a .NET-ben készült grafikus felületünkkel kommunikált volna. Ebben az esetben kizárólag az asztali alkalmazás Handle-paraméterét tudtuk volna átadni, tehát akkor is a C\# üzeneteket feldolgozó függvényével (\verb*|WndProc| -- bővebben a metódus működéséről: \ref{wndproc}) lenne dolgunk.
	
	\subsection{Listelem -- A tömb beállítása}
	Ez a függvény felelős a dev485 tömb beállításáért. Mivel itt találkozunk először a dev485-tömbbel, ezért itt fejtem ki, hogy mi a tömb funkciója. Ez a tömb úgynevezett \verb*|DEVSEL| típusú elemeket vár, ez a felmért eszközeink adatait tartalmazó struktúra. A \verb*|DEVSEL| leírja egy eszköz: \begin{itemize}
		\item azonosítóját: ez az eszköz legfontosabb attribútuma a vezérlés szempontjából, az azonosítón keresztül állíthatjuk be, és küldhetünk ki jelet egy bizonyos eszköz számára, amelyet vezérelni szeretnénk.
		\item verzióleíróját: ez egy \verb*|VERTAR| típusú objektum, amely leírja az eszközön futó vezérlőszoftver verzióját, a fejlesztés dátumát 1.00 17/11/28 formátumban.
		\item forgalmazóját: Ez számunkra egy konstans szövegérték (''Somodi László'') lesz.
		\item gyártóját: Szintén egy konstans szövegérték (''Pluszs Kft.'') lesz.
	\end{itemize}
	Optimalizációs szempontból az utóbbi két  -- ha a verziószám minden eszköznél egyezik, akkor három -- attribútumot véleményem szerint nem is érdemes \verb*|DEVSEL|-példányonként letárolni, elegendő lenne pusztán azokat, amelyek eszközönként változó értékek. Az eszközök azonosítóinak ismeretével az eszközöket vezérelni tudjuk. Az \verb*|SLDLL_Listelem| függvény ezen adatok feltöltését végzi el számunkra.	Ennek a függvénynek mindenképpen később, az \verb*|SLDLL_Open| után kell lefutnia, különben működése hibakódot eredményez.
	\subsection{Felmeres -- Eszközök felmérése}
	A hívási sorrend (szekvencia) következő lépése az \verb*|SLDLL_Felmeres|-függvény meghívása, amely az USB-porton észlelt eszköz(ök) felmérését indítja el. A nyomtatókábel USB-B vége a számítógép bármely -- szintén -- USB-B portjára csatlakoztatható. Kifejezetten előnyös tulajdonsága a metódusnak, hogy képes eldönteni, pontosan melyik porton történt meg a csatlakoztatás, így nem kell elkülönítenünk egy portot ezen eszközök detektálására.
	
	Elméletem szerint ezen függvény meghívása következett volna az \verb*|SLDLL_Open|-t követően, viszont az \verb*|SLDLL_Listelem| a gyakorlatban ezt megelőzi, mivel a vezérlés már a \verb*|WndProc|-függvényben erre kerül.  A függvény nem vár paramétert, visszatérési értéke egész szám, amely a lefutás sikerességéről tájékoztat, ezek a következők:
	\begin{itemize}
		\item \verb*|NO_ERROR|: Nem történt hiba, a végrehajtás sikeres volt.
		\item \verb*|ERROR_DLL_INIT_FAILED|: Az \verb*|SLDLL_Open| még nem lett meghívva.
		\item egyéb - Windows műveleti hibakódok.
	\end{itemize}
	\subsection{SetLista - Az eszközbeállítások végrehajtása}
	Amennyiben a \verb*|dev485|-tömb elemeit hozzárendeljük egy másik, \verb*|LISELE|-típusú elemeket tartalmazó tömbhöz. A \verb*|LISELE|-struktúrában a következő attribútumok kerülnek tárolásra: 
	\begin{enumerate}
		\item eset: Az eszköz lámpa vagy nyíl típusú
		\begin{itemize}
			\item \verb*|vilrgb|: Az eszköz milyen színnel világítson?
			\item \verb*|nilmeg|: Az eszköz milyen irányban világítson? - Háromféle értéket vehet fel: 0 -- Balra, 1 -- Jobbra, 2 -- Mindkét irányban. Amennyiben lámpáról van szó, ez az érték konstans 2 lesz.
		\end{itemize}
		\item eset: Az eszköz hangszóró típusú
		\begin{itemize}
			\item \verb*|handrb|: Hány hangot szeretnénk lejátszani a hangszóró segítségével.
			\item \verb*|hantbp|: A hangbeállítások tömbjének mutatója. Egy lejátszható hangot leír a hangerő, a hang hossza, valamint a hanglistából kiválasztott elem indexe. \ref{speaker_3ertek}
		\end{itemize}
	\end{enumerate}
	\subsection{Hangkuldes - A hangszórók vezérlése}
	A fejlesztés során a \verb*|SLDLL_SetLista| függvény meghívása nem volt elegendő a hangszórók megszólaltatásához, ezért a \verb*|SLDLL_Hangkuldes| függvényre is szükségem volt. Ennek 3 paramétere van, az első a lejátszani kívánt hangok száma, a második azok tömbje (ennek mérete az előző paraméterből következik), végül az eszköz azonosítója, amelyet meg szeretnénk szólaltatni.
	
	Az előzőekkel ellentétben az utóbbi 2 függvény nem került exportálásra, a Delphiben az általam készített \verb*|SetTurnForEachDevices|-függvény gondoskodik ezek helyes meghívásáról.
	
	Az eszköz azonosítójának ismeretével kiszámítható annak típusa, így ez származtatható attribútumnak\footnote{Származtatható attribútumnak számít adatbázisok esetében például egy személy életkora, amennyiben a születésének dátuma (év, hónap és nap) eltárolásra kerül. Ha egy adat egy vagy több másikból egyenesen következik, tehát kiszámítható, abban az esetben azt az adatot felesleges letárolni.} számít.
	\subsection{Hibakódok}
	Az alábbi táblázatban látható hibakódokat C\#-ban a következő megfelelő, egyénileg definiált kivételekkel, és sokkal kifejezőbb üzenetekkel váltom fel:
	\begin{itemize}
		\item \verb*|Dev485Exception|: Eszközök tömbjére vonatkozó hibaüzenetek.
		\item \verb*|SLDLLException|: Az SLDLL működésével kapcsolatos hibák.
		\item \verb*|USBDisconnectedException|: Hibaüzenet arról, hogy az egyik USB-porton sem észlelhető eszköz.
	\end{itemize}

	\begin{figure}[H]
		\centering
		\hspace*{-0.5in}
		\includegraphics[scale=0.5]{images/errcodes.png}
		\caption[Hibakódok és magyarázataik]{Win32-hibakódok magyarázata}
		\subcaption{Saját szerkesztés}
		\label{fig:errcodes}
	\end{figure}

	Itt látható a teljes kép az összes DLL -- a \verb*|FormHelperDLL| példányszintű metódusait leszámítva -- minden metódussal.
	\begin{figure}[H]
	\centering
	\hspace*{-0.5in}
	\includegraphics[scale=0.7]{images/fuggvenyek_kezi.jpg}
	\caption{Az elkészült állományok metódusai}
	\label{fig:fuggvenyek_kezi}
	\end{figure}
	\section{A relayDLL publikus függvényei}
	A relayDLL állomány elkészülését Dr. Király Roland Egyetemi Docens Úr javasolta abból a célból, hogy a paraméterezést, így a függvényhívások módját egyszerűsítsük, valamint a meghívható függvények listáját bővítsük.
	\subsection{Open} Az \verb*|SLDLL_Open|-függvény meghívásáért felelős, a híváshoz szükséges paraméterek számát egyre redukáltam, elegendő csupán az elkészült asztali alkalmazás Handle-címét átadni, hogy a Win32-üzenetküldés elkezdődhessen.
	
	\begin{verbatim}
		function Open(wndhnd:DWord): word; stdcall;
		var
		nevlei, devusb: pchar;
		begin
		result := SLDLL_Open(wndhnd, UZESAJ, @nevlei, @devusb); 
		end;
	\end{verbatim}

	\subsection{Listelem és Felmeres} A \verb*|SLDLL_Listelem| és \verb*|SLDLL_Felmeres|-függvények meghívása a feladatuk. Fontos, hogy a \verb*|Listelem|-függvényt C\#-ból is hívni tudjuk, mivel a Win32-üzenetek a Form részére kerülnek elküldésre, és a hívást egy beépített üzenetfeldolgozó metódus, a \verb*|WndProc| folyamán kell elvégeznünk. A \verb*|Listelem| egy egyparaméteres függvény, amely az eszközök darabszámát várja. Ezt az értéket az asztali alkalmazás fogja ismerni, mivel neki fog visszaszólni a Win32-üzenet, miután az \verb*|SLDLL_Listelem| meghívódott, így neki kell beállítania a relayDLL számára is az eszközök darabszámára vonatkozó változót. A \verb*|Felmeres| nem vár paramétert, pusztán meghívja az \verb*|SLDLL_Felmeres|-függvényt.
	
	\begin{verbatim}
		function Listelem(var numberOfDevices: byte): word; stdcall;
		begin
		result := SLDLL_Listelem(@dev485);
		drb485 := numberOfDevices;
		devListSet := false;
		end;
		
		function Felmeres(): word; stdcall;
		begin
		result := SLDLL_Felmeres();
		devListSet := false;
		end;
	\end{verbatim}

	\subsection{ConvertDEV485ToJSON}
	A metódus az SLDLL \verb*|dev485|-tömbjét C\# által is értelmezhető JSON formátumú szöveggé alakítja\footnote{Ez maga a szerializáció: egy szabványos, eltárolható, szállítható, majd helyreállítható formátum elkészítése.}. A kódban is látszik, hogy a JSON-ben kizárólag az eszközök azonosítóit küldjük át, mivel ez a tulajdonság önmagában elegendő ahhoz, hogy azokat vezérelni tudjuk. Az eszköz azonosítójából kikövetkeztethető az is, hogy milyen eszközzel van dolgunk.
	
	Az eredmény egy referenciaként átadott string paraméterből olvasható ki a függvény hívása után. Ezzel a függvénnyel közli a Delphi a C\# számára, hogy milyen eszközöket tároltunk a \verb*|dev485|-tömbben a \verb*|SLDLL_Listelem| folyamán. Ha ez a tömb valamilyen oknál fogva nem került beállításra -- ez a \verb*|SLDLL_Listelem| dolga --, úgy üres JSON-listával fog visszatérni a függvény, és tájékoztatja a felhasználót egy üzenetablakkal.
	
	\begin{verbatim}
		function ConvertDEV485ToJSON(out outputStr: WideString): byte; stdcall;
		var
			buffer: WideString;
			i: byte;
		begin
			if (drb485 = 0) or (not Assigned(dev485)) then
			begin
				showmessage(format('Dev485 is empty drb485 = %d  dev485 = %p', [drb485, @dev485]));
				outputStr := '[]';
				result := DEV485_EMPTY;
				exit;
			end;
			buffer := '[';
			i := 0;
			while i < drb485 do
			begin
				buffer := buffer + Format('{"azonos":%d},', [dev485[i].azonos]);
				inc(i);
			end;
			buffer[length(buffer)] := ']'; 
			showmessage(format('JSON-buffer = %s', [buffer]));
			outputStr := buffer;
			result := EXIT_SUCCESS;
		end;
	\end{verbatim}
	\subsection{ConvertDEV485ToJSON\_C}
	A \verb*|ConvertDEV485ToJSON\_C| pontosan azt a műveletet végzi el, amit az imént említett függvény: JSON-szerializációt. A különbség csupán annyi, hogy C-ből hívja meg a JSON-szerializációt végző függvényt. Ezt a szemléltetés kedvéért készítettem, hogy lássuk, a Delphi és a C nyelv között is tudunk kapcsolatot teremteni egy megfelelően előkészített, exportált metódusokat tartalmazó DLL segítségével, mint azt alapvetően a Delphi és a C\# között tettük.
	
	Ehhez a relayDLL egy C nyelvű komponenst, az általam készített és lefordított converter32.dll állományt hívja segítségül. Az ebben használt JSON-keretrendszert Michael Grieco szoftverfejlesztő építette fel, én kizárólag ehhez egyetlen, külső hívást megengedő, exportált függvényt készítettem úgy, hogy az Delphiből hibamentesen hívható lehessen.\cite{mgrieco}

	A függvény szignatúrája így néz ki Delphiben:
	\begin{verbatim}
		function create_json(device_ids:pinteger;length:integer):pchar; stdcall; 
		external 'converter32.dll' 
		//C-ből vettük ezt a függvényt, ez a converter32.dll-ben található
	\end{verbatim}

	Az elkészült C-függvény (\verb*|create_json|) meghívása Delphiben:
	\begin{verbatim}
		function ConvertDEV485ToJSON_C(out outputStr: WideString): byte; stdcall;
		var
		i: integer;
		device_ids: array of integer;
		begin
		SetLength(device_ids, drb485);
		for i := 0 to drb485 - 1 do
		begin
		device_ids[i] := dev485[i].azonos;
		end;
		outputStr := create_json(@device_ids[0], drb485);
		result := 0;
		end;
	\end{verbatim}
	
	Természetesen a JSON-formátum kialakításához használhattam volna külső Delphi-könyvtárakat is, mint például a \verb*|SuperObject| \cite{json_superobject}
	vagy az \verb*|LKJSON| \cite{json_lkjson} de fontosabbnak tartottam, hogy egyrészt kitaláljam ennek működését, másrészt megteremtsek esetlegesen egy újabb nyelvi kapcsolatot a C programozási nyelvvel.

	\subsubsection{Hívott függvény: create\_json}
	Mivel a Delphi 7-es verziójába alapból nem lett beépítve a JSON-formátum kezelése, ezért segítségül hívunk C-ből egy olyan függvényt, ami azt a JSON-formátumot készíti el, amire nekünk szükségünk van: 
	\begin{verbatim} 
		[{"azonos":16385}, {"azonos":32770}, {"azonos":49153}, ...]
	\end{verbatim}
	A C-nyelvű implementáció azonban hatékonyabban elvégzi ugyanezt a JSON-szerializációt.
	\subsection{ConvertDEV485ToXML} 
	A dev485 tömbből egy XML formátumú szöveget készít, amelyet egy úgynevezett \verb*|devices.xml| állományban ment ki a háttértárra.
	
	\begin{verbatim}
		function ConvertDEV485ToXML(var outPath:WideString): byte; stdcall;
		var
		xmlDocument : IXMLDOCUMENT;
		rootNode, node : IXMLNODE;
		i : byte;
		begin
		if(drb485 = 0) or (not Assigned(dev485)) then
		begin
		result := DEV485_EMPTY;
		exit;
		end;
		xmlDocument := NewXMLDocument();
		xmlDocument.Encoding := 'utf-8';
		xmlDocument.Options := [doNodeAutoIndent];
		rootNode := xmlDocument.AddChild('devices');
		for i := 0 to drb485 - 1 do 
		begin
		node := rootNode.AddChild('device');
		node.Attributes['azonos'] := dev485[i].azonos;
		end;
		xmlDocument.SaveToFile(outPath);
		showmessage('saved XML to location: ' + outPath);
		result := EXIT_SUCCESS;
		end;
	\end{verbatim}

	\subsection{SetTurnForEachDeviceJSON} 
	Az USB-portról felmért eszközöket összerendeli a \verb*|devList| elemeivel azonosítójuk szerint, majd ennek a \verb*|devList|-tömböt beállítja az eszközök beállításait leíró JSON-szerint. Ezt a függvényt meghívva, ha a JSON-formátum helyes, lényegében ,,távoli hívással'' vezérelhetjük C\# nyelvből az eszközökre kiküldött információkat: ilyen például lámpák esetében a színkód.
	
	\begin{verbatim}
		function SetTurnForEachDeviceJSON(var json_source: WideString):word; stdcall;
		var
		i, j: byte;
		jsonArrayElements: TStringList;
		json_element1, json_element2: string;
		actDeviceType: string;
		actDeviceSettings: string;
		begin
		jsonArrayElements := reduceJSONSourceToElements(json_source);
		i := 0; j := 0;
		while(j < drb485) do
		begin
		json_element1 := jsonArrayElements[i];
		json_element2 := jsonArrayElements[i+1];
		actDeviceType := extractValueFromJSONField(json_element1, 'type'); 
		actDeviceSettings := extractValueFromJSONField(json_element2, 'settings');
		if devListSet = false then 
		begin
		devList[j].azonos := dev485[j].azonos; 
		end;
		result := setDeviceByType(j, actDeviceType, actDeviceSettings);
		printErrors(result);
		inc(j);
		inc(i, 2);
		end; //case
		devListSet := true;
		result := SLDLL_SetLista(drb485, devList);
		end;
	\end{verbatim}
	
	\subsection{fill\_devices\_list\_with\_devices} Statikusan feltölti 3 eszközzel a dev485 tömböt attól függetlenül, hogy van-e csatlakoztatva egyáltalán bármi eszköz a számítógéphez. Ezt csupán a többi függvény működésének tesztelésére használtuk.
	
	\begin{verbatim}
		function fill_devices_list_with_devices(): byte; stdcall;
		begin
		if drb485 > 0 then
		begin
		result := DEV485_ALREADY_FILLED; //array is already filled
		exit;
		end;
		drb485 := 3;
		SetLength(dev485, drb485);
		dev485[0].azonos := $c004; //hangszóró típusú eszköz
		dev485[1].azonos := $8004; //nyíl típusú eszköz
		dev485[2].azonos := $4004; //lámpa típusú eszköz
		result := EXIT_SUCCESS;
		end;
	\end{verbatim}

	\section{A relayDLL privát függvényei}
	\begin{enumerate}
  		\item \verb*|reduceJSONSourceToElements|: Delphi stringlistát hoz létre a megadott JSON-tömbből
		\item \verb*|extractValueFromJSONField|:  Megkeresi a kulcsot egy JSON-elemben, és a hozzá párosított értékkel tér vissza, például: a "azonos":10 inputból kiszedi 10 értéket.
		\item \verb*|split|: A stringet megadott elválasztó karakter (delimiter) mentén darabolja fel
		\item \verb*|removeSpecialChars|: Eltávolítja a felesleges karaktereket a JSON-bemeneti karakterláncból, előkészíti azt. Ezt tekinthetjük úgy is, mint egyfajta Lexert egy fordítóprogram esetében
		\item \verb*|validateExtractedDeviceValues|: Ellenőrzi, hogy az eszközök JSON-ben érkező beállításai megfelelőek-e.
		\item \verb*|setDeviceByType|: Eldönti, hogy az adott eszköz melyik típusba tartozik (nyíl, lámpa vagy hangszóró) és meghívja a hozzá megfelelő set-módszert.
		\item \verb*|setLEDDevice|: Beállít egy LED-nyíl vagy egy LED-lámpa típusú eszközt
		\item \verb*|setSpeaker|: Beállít egy hangszórót, az indexet, a hangerőt és a lejátszandó hang hosszát várja paraméterben. Ennek van egy másik változata, ahol hangok listáját -- az előbb említett értékhármasok konkatenáltját -- is hozzá lehet rendelni a hangszóró beállításaihoz.
	\end{enumerate}

	
	\section{Az SLFormHelperDLL bemutatása}
	Az állomány a relayDLL-en keresztül meghívható SLDLL-függvényekre épült, nagyon eltúlozva egy keretrendszert biztosít Levente grafikus felületéhez támogatólag. Az eszközök JSON- (vagy XML-) formátumban érkeznek, ezek beállításai szintén JSON-ben kerülnek átadásra a relayDLL számára.
	
	\begin{figure}[H]
		\centering
		\hspace*{-0.5in}
		\includegraphics[scale=0.75]{images/formhelper_kezi.jpg}
		\caption{A FormHelperDLL felépítése}
		\label{fig:formhelper_kezi}
	\end{figure}
	
	\subsection{Létrehozott osztályok}
	\begin{enumerate}
		\item \verb*|Device|: absztrakt osztály, minden eszköz őse, ez tárolja az eszközök azonosítóját
		\item \verb*|Device.Factory|: belső absztrakt osztály, amelynek feladata a különböző eszközök példányosítása.
		\item \verb*|LEDLight|: lámpa típusú eszközök beállításainak tárolására használt osztály, ebben pusztán -- az ősében lévő azonosító mezőn kívül -- a LEDek színét tároljuk.
		\item \verb*|LEDArrow|: nyíl típusú eszközöket tárolunk benne, amely csak közvetetten öröklődik a \verb*|Device| osztályból, közvetlen őse a \verb*|LEDLight|, mivel nyilak és lámpák esetében ugyanúgy egy szín attribútum jellemzi. A nyilak sajátossága, hogy a felvillanó nyíl irányát is megadhatjuk. Mivel ez csak 3 különböző értéket vehet fel (balra, jobbra és mindkét irányban), ezért én ezt egy \verb*|Directions| nevezetű enumhoz kötöttem, hogy elrejtsek egy olyan alacsonyabb szintű információt, hogy melyik szám pontosan melyik irányt jelenti az SLDLL-ben.
		\item \verb*|Speaker|: Hangszóró eszközöket leíró osztály, egyetlen, \verb*|Sound|-elemeket tartalmazó hanglistát tartalmaz, amelyet -- amennyiben annak van eleme -- le tud játszani.
		\item \verb*|Speaker.Sound|: Egy hangszóró által lejátszható hang leírható a következő 3 értékkel:
		\begin{enumerate} \label{speaker_3ertek}
			\item index/sorszám: Ez egy egész szám, amely egy elemre hivatkozik a frekvenciákat tartalmazó tömbből, a $[0;n-1]$ intervallumból vehet fel értéket, ahol $n: $ a tömb hossza, esetünkben $n=50$.
			Ennek segítségével megadhatjuk a lejátszandó hang magasságát. Hogy véletlenül se lehessen intervallumon kívül eső értéket megadni, valamint hogy a hangmagasságok beállítása egyszerűbb, leíróbb lehessen, bevezettem egy enumot \verb*|Pitch| (hangmagasság), a Delphi oldalon ezek egész szám formájában jelennek meg.
			\item volume/hangerő: Ez egy egész szám, amely 0 és 63 között vehet fel értéket.
			\item length/időtartam: Szintén egész szám, amely 0 és 10000 között enged értéket beállítani az általam készített SLFormHelper DLL-ben. Ezzel megadhatjuk, hogy a hangszóró a lejátszáshoz mennyi időt vegyen igénybe, ez ezredmásodpercekben értendő.
		\end{enumerate}
	\end{enumerate}

	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.65]{frequencies}
		\caption{Hangszóróval lejátszható hangok listája frekvenciákra bontva}
		\subcaption{Táblázat: saját szerkesztés\\Adatok: SLDLL-állomány}
		\label{fig:frequencies}
	\end{figure}
	
	\subsection{Eszközlista és beállításainak szerializálása}
		A \verb*|dev485|-tömb átalakításra kerül a relayDLL-ben, amint be lett állítva az eszközöket tároló tömb, a \verb*|dev485|, ez a \verb*|Listelem| hívásakor zajlik le. Ennek végül 3 lehetséges változata lett: a relayDLL-ben vagy egy XML-fájlt írunk ki a háttértárra (\verb*|devices.xml|), vagy egy JSON-szöveggel tér vissza, ezt teheti úgy, hogy a saját függvényét hívja, de választhatjuk azt az irányt is, hogy egy külső, C-ben implementált függvényt hívunk meg. 
		Az alábbi függvény hívásakor átadott paraméterrel dönthetünk, hogy melyik implementációt választjuk, alapértelmezésként a Delphiben elkészített JSON
		
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.65]{images/listelem_csharp.PNG}
			\caption{A különböző szerializálási módok meghívása az SLFormHelperben}
			\label{fig:listelem_csharp}
		\end{figure}
	
		A C\# oldalon ez egy úgynevezett \verb*|SerializedDevice|-osztálynak kerül átadásra, amelyben az átadott azonosító alapján létrehozza a típusának megfelelő példányokat, majd ezt a Levente által iterálható \verb*|Devices|-listához fűzi, ezzel elértem azt, hogy a \verb*|Devices|-listában különböző eszközök lettek létrehozva, ezek beállításait minden további nélkül felül lehet írni azok vezérléséhez.
	
		Ilyenkor felvetődik egy másik kérdés: hogyan válnak a C\#-ban módosított eszközbeállítások a Delphi által is értelmezhetővé? Ezt szintén JSON-formátummal oldottuk meg, erre az \verb*|SLFormHelper| \verb*|SerializedTurnSettings|-osztálya biztosít lehetőséget, hogy a JSON-ben átadásra kerüljön egyrészt az eszközlistában szereplő eszközök típusa, másrészt azok minden beállítása típusuktól függően. Ugyanebben a formátumban feltüntettem ütemenként annak időtartamát is, ennek a JSON beolvasásakor és kimentésekor van igazán jelentősége, hogy az ütemek időzítése is rögzíthető és helyreállítható lehessen. A kiolvasott időtartamok meghatározzák, hogy az eszközbeállításokat ütemenként kiküldő \verb*|CallSetTurnForEachDevice|-függvény milyen késleltetéssel legyen meghívva a C\#-ban, tehát mikor változzanak az eszközre kiküldött beállítások, például egy pirosan világító lámpa 2 másodperc elteltével, a következő ütemben kapcsoljon ki. Ennek az ütemezésnek köszönhetően számunkra is látható, tapasztalható eredménye is van az eszközökre kiküldött jeleknek.
		Az eszközök ütemenként változó beállításait a relayDLL az erre a formátumra felkészített \verb*|CallSetTurnForEachDevice|-függvénnyel fogja a Delphi nyelvezetével az eszközök részére közölni.
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.6]{images/json_szerializalas_utemek.PNG}
		\caption{Egy lámpa és egy hangszóró 1 ütemre vonatkozó beállításai JSON-formátumban}
		\label{fig:json_settings}
	\end{figure}	
	
	\section{Problémák és megoldások}
	Ebben az alfejezetben a következő, munkánkat időnként meg-megakasztó, kutatómunkát igénylő tényezőkről kívánok szót ejteni.
	\subsection{Egyénileg definiált típusok és struktúrák}
	\subsubsection{A probléma leírása} A Delphis projekt erősen függ az SLDLL-ben megkívánt típusoktól, ezért a teljes kódot nem tudjuk C\#-ra átültetni.
	\subsubsection{Megoldás} 
	Erre a problémára megoldást nyújthat akár a marshalling, akár a szerializáció, mi a projektben utóbbi módszert választottuk az előző problémából levont következtetés miatt: ha stringet át tudunk adni, akkor bármilyen típust képesek vagyunk leírni szöveges formában, ezt átadva újból fel tudjuk építeni a másik nyelvben. A C\#-os objektumok példányai egy erre dedikált forrásból (JSON-formátumú szövegből) fognak értékeket kapni.
	
	A lényege a megoldásnak, hogy szerializálással küszöböljük ki a két nyelv közötti kompatibilitási hiányosságokat, ezért csak olyan adatokkal kommunikálunk, amelyek ismertek, feldolgozhatóak mindkét nyelv számára. Ilyenek a primitívek, az egész, lebegőpontos, logikai és szöveges típusok).
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.89]{json_szerializalas_azonositok}
		\caption{Eszközök azonosítóinak átadása JSON-formátumon keresztül}
		\label{json_azonositok}
	\end{figure}

	\subsection{JSON-formátumra konvertáló függvények hívása .NET keretrendszerből}
	\subsubsection{A probléma leírása} Az SLDLL funkcióit szeretnénk kibővíteni az XML- és JSON-szerializációt végző függvényekkel egy külön állományban. Ebben a felmért eszközök tömbjének (\verb*|dev485|) ugyanúgy elérhetőnek kell lennie.
	\subsubsection{Megoldás} A korábbi SLDLL-hez fűzzük őket, vagy tegyük egy új DLL-állományba őket, és ezeket is meg kell hirdetnünk a C\#-os futtatókörnyezet számára is. A választott megoldásom az új DLL-re esett, egy úgynevezett relayDLL nevezetű állomány forráskódját megírtam Delphiben, amelyen keresztül az SLDLL-függvényeket meg tudjuk hívni.
	
	Ennek legfőbb indoka az volt, ami eldöntötte, hogy érdemes a hívó (.NETben készült FormHelperDLL) és hívott (SLDLL) felek között egy köztes réteget elkészíteni, hogy Delphiben különböző globális változók kapnak értéket, amelyeket nem tudunk máshol definiálni, tehát a hívás környezetét így tudjuk megteremteni, hogy az értékadások ténylegesen működjenek, ne fussunk \verb*|NullReferenceException|-hibákra.
	
	A relayDLL használatával ellenőrzöttebb módon tudom meghívni az SLDLL-ben meghirdetett függvényeket, ebből nem is kell mindent meghirdetni, csak annyit, amennyit ténylegesen a vezérléshez használnunk szükséges. Ezenkívül több, általam definiált hibakódot is vissza tudok adni, amelyek kiváltó okáról C\#-ban megfelelő kivételek segítségével tájékoztatni tudjuk a felhasználókat.
	\subsection{Az SLDLL\_Open-függvény paraméterezése}
	\subsubsection{A probléma leírása} Az \verb*|SLDLL_Open|-függvény várja az ablakos alkalmazástól egy úgynevezett Handle-t, amely az üzenetküldést engedélyezi az SLDLL-függvények részéről.
	\subsubsection{Megoldás} C\#-ban a Windows Form -- mint függvényeket meghívó fél -- egy Handle nevezetű pointerrel\footnote{A pointer egy olyan változó, amely memóriacímet képes tárolni. Mérete a memóriacímek méretezésétől függ (például 64bites rendszereken 8 bájt ír le egy memóriacímet, ezért egy pointer tárigénye is ennyi lesz.).} rendelkezik, amit átadhatunk az SLDLL-nek.
	\subsection{Stringek átadása két nyelv között}
	\subsubsection{A probléma leírása} Különösen fontos, hogy Delphiből valamilyen formában át tudjunk adni a C\# részére szöveg típusú változókat, mivel ha ez működik, akkor lényegében segítségükkel bármilyen más típus formátuma is -- így a rekordoké is -- leírható és feldolgozható.
	
	\subsubsection{Megoldás}
	Stringek formájában alapértelmezetten a C\# marshalling komponense Delphiből \verb*|PWideChar| típusú változókat vár. Amennyiben Delphiben a metódus WideStringet kér paraméterben, akkor azt a C\#-oldali marshallerrel a \verb*|[MarshalAs(UnmanagedType.BStr)]| attribútum segítségével tudjuk közölni.\cite{sof_strhandling}
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.85]{string_delphi}
		\caption{A függvény helyes Delphi-deklarációja}
		\label{string_delphi}
	\end{figure}

	Magyarázat a \verb*|DllImport|nak átadott paraméterekről:
	\begin{itemize}
		\item \verb*|Charset.Unicode|: utasítja a marshallert arra, hogy UTF-16 formátumban értelmezze a szöveget, hacsak nincs más utasítás.
		\item \verb*|CallingConvention.StdCall|: Az adott függvény által elfogadott ''hívási konvencióra'' utal. Azt jelenti, hogy a hívott fél, a relayDLL végzi a hívási verem (call stack) felszabadítását.
		\item \verb*|DLLPATH|: konstans érték, a relayDLL relatív elérési útja az SLFormHelperDLL mappájához viszonyítva, arra vonatkozik, hogy hol keresse a marshaller az adott függvény implementációját.
		\item \verb*|EntryPoint='ConvertDEV485ToJSON'|: A marshaller ezen a néven keresi az adott függvény implementációját a relayDLL-ben.
		\item \verb*|[MarshalAs(UnmanagedType.BStr)]|: A kimenő paraméterként átadott változót ilyen formában küldi át a Delphinek, és ilyen formában várja is azt vissza. A Delphiben készült függvény WideString paraméterére a C\#-ban stringként átadott változó így fog illeszkedni. Ez a string átadásának egyik lehetséges párosítása.
	\end{itemize}

	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.8]{string_csharp}
		\caption{A függvény helyes szignatúrája C\#-ban}
		\label{string_csharp}
	\end{figure}

	\subsection{A Delphiben eldobott kivételek nem kezelhetőek}
	\subsubsection{A probléma leírása} Delphiben dobott kivételeket a C\# úgy érzékeli, mint ''hiba a külső komponensben'', a tényleges kiváltó okát nem tudjuk meg.
	\subsubsection{Megoldás} Hibakódokkal jelezzük a C\# felé, ha esetleg hibára futott valamelyik relayDLL-függvény, ebből a hibakódból a C\# tudni fogja, hogy milyen típusú kivételt dobjon az asztali alkalmazás számára. Ezekből egyedi kivételfajták készíthetők.
	\subsection{uzfeld-metódus megfelelője C\#-ban}
	\subsubsection{A probléma leírása} Delphiben az ablakos alkalmazásnak volt egy úgynevezett \verb*|uzfeld| nevezetű metódusa, amely a DLL üzeneteinek kezelésére szolgált, ez hívódik meg az \verb*|SLDLL_Open| meghívása után\footnote{Ez a tény, hogy a Listelem-függvény tulajdonképpen a Felmeres előtt kell, hogy meghívódjon, a Delphi7-es fejlesztői környezetének debug és breakpoint funkcióinak segítségével derült ki. Ennek használatával sorról sorra tudtam követni a program végrehajtását.} (ezért került átadásra a formot azonosító Handle). Ez azért fontos, mert az \verb*|SLDLL_Listelem|-függvény ezen az uzfeld-metóduson keresztül kerül meghívásra, a drb485 és a dev485 a program ezen pontján kapnak ténylegesen értelmezhető értékeket.
	\subsubsection{Megoldás}
	\label{wndproc}
	Elméletem szerint létezik ennek egy szabványos megfelelője, C\#-ban ez \verb*|WndProc|-metódus, ami szintén \verb*|Message| típusú változót vár referencia szerint átadva, ezzel tud az SLDLL futásidőben kommunikálni.
	Innentől kezdve a következő lépések játszódnak le:
	\begin{enumerate}
		\item A DLL működését elindító \verb*|SLDLL_Open| kivált egy Win32-üzenetet. A paraméterben átadjuk a Form Handle-mezőjét, ezzel az operációs rendszer tudja, hogy melyik alkalmazással kell kommunikálnia.
		\item Az üzenet felkerül a Win32 üzenetsorra (Message Queue), ezt kiolvasva operációs rendszer meghívja a Form \verb*|WndProc| metódusát.
		\item Amennyiben a felmérés sikeresen lezajlott, a \verb*|WndProc| meghívja a relayDLL \verb*|dev485| és \verb*|drb485| változóit beállító \verb*|SLDLL_ListElem|-függvényt, mielőtt az \verb*|SLDLL_Felmeres|re kerülne a sor. A megfelelő hívási szekvencia így automatikusan biztosított.
	\end{enumerate}
	\subsection{Eszközök azonosítóinak, típusainak átadása}
	\subsubsection{A probléma leírása} Hogyan közöljük a felmért (USB-re csatlakoztatott) eszközök azonosítóját és típusát a C\# részére?
	\subsubsection{Megoldás}
	A Delphiben tárolt tömb (\verb*|dev485|) eszközeinek legfontosabb mezőjét (ami az eszközt azonosítója, tehát az azonosítót XML-fájlba kimentjük \cite{sof_xmlcreate}, vagy JSON-formátumú szöveggé alakítjuk. Az azonosító önmagában meghatározza az eszköz típusát, úgyhogy elég azt átadni.
	Egy eszköz típusának megfelelően a következő intervallumokból kaphat azonosítót:
	\begin{itemize}
		\item \verb*|SLLELO| (lámpa): 0x4000 -> $[0x4000\,,\,0x4fff]$ ez decimálisan ezt a tartományt fedi le: $[16\,384\,,\,20\,479]$
		\item \verb*|SLNELO| (nyíl): 0x8000 -> $[0x8000\,,\,0x8fff]$ ez decimálisan ezt a tartományt fedi le: $[32\,768\,,\,38\,683]$
		\item \verb*|SLHELO| (hangszóró): 0xc000 -> $[0xc000\,,\,0xcfff]$ ez decimálisan ezt a tartományt fedi le: $[49\,152\,,\,53\,257]$
	\end{itemize}
	
	Az eszköz típusának meghatározásában nem játszik szerepet az utolsó 3 bitnégyes, tulajdonképpen a legfelső hex\footnote{4 bit azonosít egy hexadecimális számjegyet -- 0-tól F-ig terjedően --, így a bitnégyest hexnek is nevezhetjük.} azonosítja a típust.
	Ha szigorúan hexadecimálisan nézzük, akkor például ha egy szám négyjegyű és balról tekintve a legelső számjegye C, akkor az azonosító hangszórót fog jelölni.
	
	Mivel az azonosítóból egy számítással kikövetkeztethető eszköz típusa, ezért elegendő a C\# DLL-nek ezt az értéket átadni, amely értékből le tudja gyártani a maga példányait.
	
	\begin{algorithm}
		\caption{Egy eszköz típusának meghatározása}
		\label{algo:createdevice}
		\begin{algorithmic}[0]
		\Function{CreateDevice}{azonos: int}
			\State $deviceType:int\,\gets\,azonos\ \mathbin{\&}\ 0xc000$; \Comment{\&: bitenkénti AND-művelet}
			\If{deviceType = $0x4000$}
				\State $CreateDevice \gets Device.Factory.CreateLight(azonos)$;
			\ElsIf{deviceType = $0x8000$}
				\State $CreateDevice \gets Device.Factory.CreateArrow(azonos)$;
			\ElsIf{deviceType = $0xc000$}
				\State $CreateDevice \gets Device.Factory.CreateSpeaker(azonos)$;
			\Else
				\State $CreateDevice \gets null$;
			\EndIf
		\EndFunction
		\end{algorithmic}
	\end{algorithm}

	A megoldás a RESTful alkalmazásokból inspirálódik, amelyről a(z) \ref{rest} alfejezetben ejtettem szót, a C\# és a Delphi között akár az XML, akár a JSON közös nyelvként (hídként) szolgál. Ebben az analógiában a relayDLL számít a szervernek, ennek függvényeit az SLFormHelper kliensként hívhatja.
	\subsection{A hangszóró egy egész hanglistát kezel}
	\subsubsection{A probléma leírása} A hangszórók nem feltétlenül csak egy bizonyos hang, hanem egy egész hangsorozat lejátszására is képesek. 
	\subsubsection{Megoldás - JSON-formátum feldolgozása Delphiben}
	Egy lejátszandó hangot az előbb említett értékhármas (sorszám, hangerő és időtartam) ír le. \ref{speaker_3ertek}
	Egy hanglistát több \textit{index|volume|length}-hármas ír le, a pipe, azaz '|'-karakter mentén széttördelt szövegen 3 lépésközzel iterálhatunk végig.
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.8]{speaker_solved}
		\caption{Megoldás a hangszóró hanglistájának kezelésére - relayDLL}
		\label{speaker_solved}
	\end{figure}

	\subsubsection{Megoldás - JSON-formátum előállítása C\#-ban}
	A \verb*|Speaker|-osztályban az eszköz viselkedését leíró 3 mezőt (index, volume és length) egy külön objektumba szervezzük ki (\verb*|Sound|), és a \verb*|Speaker| -- azonosítóján kívül -- kizárólag \verb*|Sound| típusú objektumok listáját tartalmazza, a listát JSON-ben \textit{"index|volume|length"} rendezett hármasok összefűzésével szerializálja, a listához kizárólag listakezelő függvényekkel lehet hozzáférni (törlés, módosítás, hozzáadás), majd az \verb*|SLDLL_Hangkuldes| számára kiküldött \verb*|H|-tömböt (hanglistát) Delphiben egy ciklussal a JSON-nel átadott adatok szerint a megfelelő sorrendben feltöltjük, az előző probléma megoldásában ennek mikéntjét kifejtettem.
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.53]{speaker_csharp}
		\caption{A hangszóró hanglistát kezel - megoldás C\# nyelven}
		\label{speaker_csharp}
	\end{figure}

	\subsection{\ Több csatlakoztatott eszköz felismerése, vezérlése}
	\subsubsection{A probléma leírása}
	A rajzon látható módon kötöttük be az eszközöket, és háromból 2 eszközt érzékelt a \verb*|dev485|-tömbben, valamint csak egy, az USB portra közvetlenül csatlakozó (legelső) elemnek küldte ki a jeleket, a többi egyszerűen ,,elnyelődött''.
	Amikor 2 eszközt, egy lámpát és egy nyilat csatlakoztattam, akkor egyrészt a telefonkábel folyamatosan, érezhetően melegedett, másrészt 
	\renewcommand{\labelenumi}{\alph{enumi})}
	\begin{enumerate}
		\item vagy állandóan piros színnel világított, 
		\item vagy piros - zöld - kék jelzéseket követően kikapcsolt.
	\end{enumerate}
	Az első esetben szimplán nem érzékelte az USB-porton lévő eszközöket -- ez az 1626-os (\verb*|ERROR_FUNCTION_NOT_CALLED|) hiba az \verb*|SLDLL_Open| függvény lefutásakor --, az alábbi hibakódot dobja az eszközök felmérésekor.
	\subsubsection{Megoldás} Az általunk használt telefonkábelek két végén a középső erek bekötése egymással ellentétes volt, továbbá a két szélső, a sárga és fekete ereken átfolyó stabil egyenáram zajként szolgált, egyúttal ez okozta a kábel folyamatos melegedését is. Elegendő volt csupán a két középső, a piros és zöld ereket rendre -- balról jobbra --  bekötni, majd egy krimpelő fogó segítségével az RJ9-es csatlakozóhoz erősíteni. Az ily módon elkészült kábel alkalmassá teszi az eszközöket a soros kommunikációra.

	Két eszköz megfelelő összekapcsolásának módja az alábbi ábrán látható. A laptopot nyomtatókábellel kapcsoljuk a legelsőnek szánt eszközhöz, majd ezt követően a(z) \ref{fig:foto_rj9} ábrán látható telefonkábeleket csatlakoztatunk a két összekapcsolni kívánt eszköz valamely, erre a célra szánt portjára. Az eszközök hátulján két ilyen port található abból a feltételezhető célból, hogy mindegyik eszköz esetlegesen középső elemként is tudjon szolgálni, amelynek lehetnek balról és jobbról csatlakozó szomszédjai is. A fejlesztés során mi mindig az eszköz szemből vett bal oldalán lévő RJ9-foglalatot vettük igénybe. Az USB-portunk így adatot már igen, tápfeszültséget azonban nem tud a közvetlenül nem csatlakoztatott eszközök számára biztosítani. Ennek megoldására egy konnektoron hálózati feszültségre kell csatlakoztatnunk a szóban forgó eszközöket darabonként egy-egy tápkábel (\ref{fig:foto_tapkabel} ábra) segítségével. 
	Ekkor az SLDLL az eszközök felmérésekor már több, mint egy csatlakoztatott eszközt is képes észlelni, ezek együttesen vezérelhetőek.
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.5]{images/foto_sorbakotes.jpg}
		\caption{Két eszköz csatlakoztatásának módja.}
		\label{fig:foto_sorbakotes}
	\end{figure}

	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.35]{images/foto_foglalatok.jpg}
	\caption{Egy eszköz hátulján lévő foglalatok.}
	\label{fig:foto_foglalatok}
	\end{figure}
	
	\subsection{Az elkészített forráskódok}
	\begin{enumerate}
		\item FormHelperDLL és relayDLL állományok forráskódjai itt érhetőek el: \hyperref{https://github.com/nagytoth1/dzkbx0_thesis_repo}{}{}{Github}
		\item converter32DLL állomány forráskódja itt érhető el: \hyperref{https://github.com/nagytoth1/jsonConverterC/}{}{}{Github}
	\end{enumerate}
	
	\section{Összegzés és kitekintés}
	Két ismert programozási nyelv között megteremthető kommunikáció kiaknázásával elértem, hogy egy olyan szoftver készülhessen el, amelynek segítségével szakemberek képessé válhatnak emberek mentális egészségének fejlesztésére. 
	
	Örömömre szolgált, hogy Somodi László minket bízott meg elméleteit kivitelező szoftveres háttérrel. Szakdolgozatunk nem kizárólag arról szól, hogy szakmai tudásunkat gyarapítsuk és mutassuk bizonyítványként egyetemi oktatóink felé, hanem ezzel a projekttel sok ember számára tudunk további segítséget nyújtani magunk legjobb tudása szerint.
	
	Kifejezetten tetszik, hogy munkánkat több tudományág szakértője segítette, így kutatásunk interdiszciplinárisként is jellemezhető, azaz több szakterület, jelesül a mozgáskoordináció, beágyazott rendszerek vezérlése, együttes munkájának az eredményének részesei lehettünk.
	
	A szoftverfejlesztés elméleti és gyakorlati alapjait egyrészt az Egyetem oktatóitól, szakmai és technikai vonulatait Dr. Király Roland Egyetemi Docens Úrral folytatott konzultációinkon szerzett információk biztosították. 
	
	Inspirációnkat, motivációnkat Somodi Lászlóval való beszélgetéseinkből, valamint \textit{,,Mozgáskoordináció- és gyorsaságfejlesztő gyakorlatok óvodától a felnőtt korig''} címet viselő könyvében leírt gondolatokból merítettük.
	
	Mint minden szoftverre és emberi termékre jellemző, a megoldásaink természetesen nem mondhatóak tökéletesnek, programunk épp annyira időnként karbantartásra és további fejlesztésekre szorulhat. Érdekes volt felfedezni a gRPC és a Proto-nyelv kapcsán a \ref{grpc} fejezetben, hogy ötször-hatszor jobb teljesítmény érhető el az adatok bináris módon történő szerializációjával a szöveges formátumokhoz képest -- jelen állás szerint mégis az utóbbi megoldás számít elterjedtebbnek --, én azt gondolom, hogy mindenképp érdemes lenne munkánkat esetleg egy újabb szakdolgozat keretein belül gRPC használatával is továbbgondolni.
	\newpage
	\section{Köszönetnyilvánítás}
	Szeretném ezúton is megköszönni konzulensemnek, Dr. Király Roland Egyetemi Docens Úrnak a tanulmányaimban nyújtott támogatását és szakmai útmutatását. Szakértelme és tapasztaltsága segített engem abban, hogy munkámat megérthessem, elkezdhessem, folytathassam, végül sikeresen lezárhassam.
	
	Külön köszönet illeti a barátnőmet, aki nagy türelemmel támogatott és motivált engem, így aktívan hozzájárult ahhoz, hogy szakdolgozatom időről időre minél jobbá válhasson.
	
	Szeretnék köszönetet mondani barátaimnak és családomnak is a szeretetükért, türelmükért és támogatásukért.
	
	Köszönöm az Eszterházy Károly Katolikus Egyetemen folytatott tanulmányaimban résztvevő valamennyi oktatónak idejüket és igyekezetüket, hogy szaktudásukat megosszák velünk.
	
	Köszönöm az Eszterházy Károly Katolikus Egyetemen dolgozó valamennyi oktatónak, amely itt folytatott tanulmányaimban részt vett, hogy idejüket és igyekezetüket arra szánták, hogy szaktudásukat megosszák velünk. 
		
	Végezetül szeretnék hálát adni a jó Istennek, hogy vigyázott rám, így testi, szellemi és lelki épségben el tudtam végezni ezt a munkát is. Belé vetett hitem segített abban, hogy szakdolgozatomat minden akadályozó tényező ellenére is folytatni tudjam.
	\bibliographystyle{plain}
	\bibliography{references}
	\listoffigures
	% Aláírt, szkennelt nyilatkozat beillesztése a szakdolgozat végére
	\includepdf{nyilatkozat.pdf}
\end{document}